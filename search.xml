<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>margin 和 padding 分别适合什么场景</title>
      <link href="/2022/08/16/margin-he-padding-fen-bie-gua-he-shi-me-chang-jing/"/>
      <url>/2022/08/16/margin-he-padding-fen-bie-gua-he-shi-me-chang-jing/</url>
      
        <content type="html"><![CDATA[<p><code>margin</code>是用来隔开<mark>元素与元素</mark>的间距；<code>padding</code>是用来隔开<mark>元素与内容</mark>的间隔。<br><code>margin</code>用于布局分开元素使元素与元素互不相干。<br><code>padding</code>用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</p><h3 id="何时应当使用margin"><a href="#何时应当使用margin" class="headerlink" title="何时应当使用margin"></a>何时应当使用margin</h3><ul><li>需要在border外侧添加空白时。</li><li>空白处不需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</li></ul><h3 id="何时应当时用padding"><a href="#何时应当时用padding" class="headerlink" title="何时应当时用padding"></a>何时应当时用padding</h3><ul><li>需要在border内测添加空白时。</li><li>空白处需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 优化、提高性能的方法</title>
      <link href="/2022/08/15/css-you-hua-ti-gao-xing-neng-de-fang-fa/"/>
      <url>/2022/08/15/css-you-hua-ti-gao-xing-neng-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="加载性能"><a href="#加载性能" class="headerlink" title="加载性能"></a>加载性能</h2><ol><li><strong>css压缩</strong>：将写好的css进行打包压缩，可以减少很多的体积。</li><li><strong>css单一样式</strong>：当需要下边距和左边距的时候，很多时候选择:<code>margin:top 0 bottom 0;</code>但<code>margin-bottom:bottom;</code> <code>margin-left:left;</code>执行的效率更高。</li><li><strong>减少使用@import,而建议使用link</strong>，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ol><h2 id="选择器性能"><a href="#选择器性能" class="headerlink" title="选择器性能"></a>选择器性能</h2><ol><li><p>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择器是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p></li><li><p>如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</p></li><li><p>避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</p></li><li><p>尽量少的去对标签进行选择，而是用class。</p></li><li><p>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</p></li><li><p>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p></li></ol><h2 id="渲染性能"><a href="#渲染性能" class="headerlink" title="渲染性能"></a>渲染性能</h2><ol><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li><li>属性值为0时，不加单位。</li><li>属性值为浮动小数0.**，可以省略小数点之前的0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li><li>不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li></ol><h2 id="可维护性、健壮性"><a href="#可维护性、健壮性" class="headerlink" title="可维护性、健壮性"></a>可维护性、健壮性</h2><ol><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清除浮动</title>
      <link href="/2022/08/15/qing-chu-fu-dong/"/>
      <url>/2022/08/15/qing-chu-fu-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要清除浮动？"><a href="#为什么需要清除浮动？" class="headerlink" title="为什么需要清除浮动？"></a>为什么需要清除浮动？</h2><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现<strong>“高度塌陷”</strong>。</p><p>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</p><h2 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h2><ol><li>使用clear属性清除浮动。</li></ol><h3 id="使用-clear-属性清除浮动的原理"><a href="#使用-clear-属性清除浮动的原理" class="headerlink" title="使用 clear 属性清除浮动的原理"></a>使用 clear 属性清除浮动的原理</h3><p>使用clear属性清除浮动，其语法如下：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">clear</span><span class="token punctuation">:</span>none|left|right|both<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果单看字面意思，<code>clear:left</code>应该是“清除左浮动”，<code>clear:right</code>应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性的解释是：<mark>“元素盒子的边不能和前面的浮动元素相邻。”</mark>，我们对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是<code>left</code>，要么是<code>right</code>，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当<code>clear:left</code>有效的时候，<code>clear:right</code>必定无效，也就是此时<code>clear:left</code>等同于设置<code>clear:both</code>；同样地，<code>clear:right</code>如果有效也是等同于设置<code>clear:both</code>。由此可见，<code>clear:left</code>和<code>clear:right</code>这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用<code>clear:both</code>吧。</p><p>一般使用伪元素的方式清除浮动:</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.clear::before,  // 解决外边距重叠的问题.clear::after</span><span class="token punctuation">{</span>   // 解决高度塌陷的问题<span class="token property">content</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">;</span><span class="token property">display</span><span class="token punctuation">:</span>table<span class="token punctuation">;</span> //也可以是<span class="token string">'block'</span>，或者是<span class="token string">'list-item'</span><span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>clear属性只有块级元素才有效的，而<code>::after</code>等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置<code>display</code>属性值的原因。</p><ol><li>使用BFC块级格式化上下文来清除浮动。<br>因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC 规范</title>
      <link href="/2022/08/15/bfc-gui-fan/"/>
      <url>/2022/08/15/bfc-gui-fan/</url>
      
        <content type="html"><![CDATA[<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>块级格式化上下文（<code>Block Formatting Context</code>，<code>BFC</code>）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲</p><ul><li>BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。</li><li>如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</li></ul><p><i>创建BFC:</i></p><ol><li>根元素或包含根元素的元素</li><li>浮动元素<code>float＝left|right或inherit（≠none）</code></li><li>绝对定位元素<code>position = absolute</code>或<code>fixed</code></li><li><code>display＝inline-block|flex|inline-flex|table-cell</code>或<code>table-caption</code></li><li><code>overflow＝hidden|auto</code>或<code>scroll(≠visible)</code></li></ol><p>一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，<code>display</code>属性的值为<code>inline-block</code>、<code>flex</code>这些属性时也会创建BFC。还有就是元素的<code>overflow</code>的值不为<code>visible</code>时都会创建BFC。</p><h3 id="IFC-是什么"><a href="#IFC-是什么" class="headerlink" title="IFC 是什么?"></a>IFC 是什么?</h3><p>IFC指的是<ins>行级格式化上下文</ins>，它有这样的一些布局规则：</p><ol><li>行级上下文内部的盒子会在水平方向，一个接一个地放置。</li><li>当一行不够的时候会自动切换到下一行。</li><li>行级上下文的高度由内部最高的内联盒子的高度决定。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>display、position和float的相互关系</title>
      <link href="/2022/08/15/display-position-he-float-de-xiang-hu-guan-xi/"/>
      <url>/2022/08/15/display-position-he-float-de-xiang-hu-guan-xi/</url>
      
        <content type="html"><![CDATA[<ol><li>首先我们判断<code>display</code>属性是否为<code>none</code>，如果为<code>none</code>，则<code>position</code>和<code>float</code>属性的值不影响元素最后的表现。</li><li>然后判断<code>position</code>的值是否为<code>absolute</code>或者<code>fixed</code>，如果是，则<code>float</code>属性失效，并且<code>display</code>的值应该被设置为<code>table</code>或者<code>block</code>，具体转换需要看初始转换值。</li><li>如果<code>position</code>的值不为<code>absolute</code>或者<code>fixed</code>，则判断<code>float</code>属性的值是否为<code>none</code>，如果不是，则<code>display</code>的值则按上面的规则转换。注意，如果<code>position</code>的值为<code>relative</code>并且<code>float</code>属性的值存在，则<code>relative</code>相对于浮动后的最终位置定位。</li><li>如果<code>float</code>的值为<code>none</code>，则判断元素是否为根元素，如果是根元素则<code>display</code>属性按照上面的规则转换，如果不是，则保持指定的<code>display</code>属性值不变。</li></ol><p>总的来说，可以把它看作是一个类似优先级的机制，<code>position:absolute</code>和<code>position:fixed</code>优先级最高，有它存在的时候，浮动不起作用，<code>display</code>的值也需要调整；其次，元素的<code>float</code>特性的值不是<code>none</code>的时候或者它是根元素的时候，调整<code>display</code>的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，<code>display</code>特性值同设置值。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用图片 base64 编码的优点和缺点</title>
      <link href="/2022/08/15/shi-yong-tu-pian-base64-bian-ma-de-you-dian-he-que-dian/"/>
      <url>/2022/08/15/shi-yong-tu-pian-base64-bian-ma-de-you-dian-he-que-dian/</url>
      
        <content type="html"><![CDATA[<p>base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url属性。</p><p>使用base64的<mark>优点</mark>是：</p><ol><li>减少一个图片的HTTP请求</li></ol><p>使用base64的<mark>缺点</mark>是：</p><ol><li>根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。</li><li>使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如<code>HTML</code>或者<code>CSS</code>，这相比于直接缓存图片的效果要差很多。</li><li>兼容性的问题，ie8以前的浏览器不支持。</li></ol><p>一般一些网站的小图标可以使用base64图片来引入。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>width:auto 和 width:100%的区别</title>
      <link href="/2022/08/15/width-auto-he-width-100-de-qu-bie/"/>
      <url>/2022/08/15/width-auto-he-width-100-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><code>width:100%</code>会使元素box的宽度等于<mark>父元素</mark>的<code>content box</code>的宽度。</p><p><code>width:auto</code>会使元素撑满整个父元素，<code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code>区域会自动分配水平空间。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>visibility 属性</title>
      <link href="/2022/08/15/visibility-shu-xing/"/>
      <url>/2022/08/15/visibility-shu-xing/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>visible</code></td><td><strong>默认值</strong>。元素是可见的。</td></tr><tr><td><code>hidden</code></td><td>元素是不可见的。但是其他元素的布局不改变，相当于此元素变成透明。</td></tr><tr><td><code>collapse</code></td><td>当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。（与将 <code>display: none</code> 用于表格的行/列上的效果相当）。但是，仍会计算其他行和列的大小，就好像折叠的行或列中的单元格一样。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为<code>hidden</code>。</td></tr><tr><td><code>inherit</code></td><td>规定应该从父元素继承 visibility 属性的值。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是包含块</title>
      <link href="/2022/08/15/shi-me-shi-bao-han-kuai/"/>
      <url>/2022/08/15/shi-me-shi-bao-han-kuai/</url>
      
        <content type="html"><![CDATA[<p>包含块（containing block）就是元素用来计算和定位的一个框。</p><ol><li>根元素（很多场景下可以看成是<code>&lt;html&gt;</code>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</li><li>对于其他元素，如果该元素的<code>position</code>是<code>relative</code>或者<code>static</code>，则“包含块”由其最近的块级祖先元素的<code>content box</code>边界形成。</li><li>如果元素<code>position:fixed</code>，则“包含块”是“初始包含块”。</li><li>如果元素<code>position:absolute</code>，则“包含块”由最近的<code>position</code>不为<code>static</code>的祖先元素建立，具体方式如下：<br>如果该祖先元素是纯inline元素，则规则略复杂：</li></ol><ul><li>假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的<code>padding box</code>外面的包围盒就是内联元素的“包含块”；</li><li>如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥否则，“包含块”由该祖先的<code>padding box</code>边界形成。<br>如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="/2022/08/09/fang-dou-he-jie-liu/"/>
      <url>/2022/08/09/fang-dou-he-jie-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次。</p><h3 id="手写防抖函数"><a href="#手写防抖函数" class="headerlink" title="手写防抖函数"></a>手写防抖函数</h3><p>假设我们要点击一个按钮新增一条信息，当然我们不希望每次点击都调用接口新增，我们希望多次点击只新增一次。<br><img src="https://img-blog.csdnimg.cn/4839ac1149844caa942cdfd72f696170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YmN56uv6bKB54-t,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>首先我们先简单的模拟一个按钮被点击的过程。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> addBtn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'添加数据'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>addBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span>addOne<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为我们需要对执行的事件进行处理所以接下来我们需要封装一下addOne函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> addBtn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'添加数据'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fun</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>addBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token function">debounce</span><span class="token punctuation">(</span>addOne<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面我们用闭包处理了一下addOne函数，接下来我们需要添加一个延时器setTimeout来倒计时，当我们点击按钮后过2s再执行。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fun<span class="token punctuation">,</span>time</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>time<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>addBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token function">debounce</span><span class="token punctuation">(</span>addOne<span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们的一个防抖功能就完成了，但是这还没完，如果我们在addOne()打印this会发现我们这样执行的this是指向Window的。</p><p>这当然不是我们所希望的，我们需要使用apply来改变this指向，再者就是我们需要考虑到执行函数的参数，因为不同的函数肯定会有不同的参数传入,对于参数我们可以使用arguments处理。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fun<span class="token punctuation">,</span>time</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> timer  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments    timer<span class="token operator">=</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>      <span class="token function">fun</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>time<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。</p><h3 id="手写节流函数"><a href="#手写节流函数" class="headerlink" title="手写节流函数"></a>手写节流函数</h3><p><strong>原理：定义一个开关变量flag，调用的时候把它赋值为true，然后再写一个定时器，待定时器结束后再赋值为false。 再定时器还未结束期间，再次调用函数时判定flag，为true的话直接return就行。</strong></p><p>极简版</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token comment">// true 表示上次执行未结束</span>    flag <span class="token operator">=</span> <span class="token boolean">true</span>    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        flag <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 结束后重新设置为false</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment">// 测试函数</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">}</span> window<span class="token punctuation">.</span><span class="token function-variable function">onscroll</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// test() // 不用节流的话，页面滚动一直在调用</span>    <span class="token function">throttle</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// 加上节流，即使页面一直滚动，也只会每隔一秒执行一次test函数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化版</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 把变量放函数里面，避免全局污染</span>    <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token keyword">let</span> arg <span class="token operator">=</span> arguments <span class="token comment">// 此处为fn函数的参数</span>        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> arg<span class="token punctuation">)</span>            flag <span class="token operator">=</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">let</span> throttleTest <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> window<span class="token punctuation">.</span><span class="token function-variable function">onscroll</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">throttleTest</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向数据绑定</title>
      <link href="/2022/08/09/shuang-xiang-shu-ju-bang-ding/"/>
      <url>/2022/08/09/shuang-xiang-shu-ju-bang-ding/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是双向绑定"><a href="#什么是双向绑定" class="headerlink" title="什么是双向绑定"></a>什么是双向绑定</h2><p>我们先从单向绑定切入，单向绑定非常简单，就是把<code>Model</code>绑定到<code>View</code>，当我们用<code>JavaScript</code>代码更新<code>Model</code>时，<code>View</code>就会自动更新。双向绑定就很容易联想到了，在单向绑定的基础上，用户更新了<code>View</code>，<code>Model</code>的数据也自动被更新了，这种情况就是双向绑定，举个栗子：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6670e41c23314a98c684055933075a18.png"></p><p>当用户填写表单时，<code>View</code>的状态就被更新了，如果此时可以自动更新<code>Model</code>的状态，那就相当于我们把<code>Model</code>和<code>View</code>做了双向绑定关系图如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8f42b7a30579e7d246baa0617bfce5ad.png"></p><h2 id="双向绑定的原理是什么"><a href="#双向绑定的原理是什么" class="headerlink" title="双向绑定的原理是什么"></a>双向绑定的原理是什么</h2><p>我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成</p><ul><li>数据层（Model）：应用的数据及业务逻辑</li><li>视图层（View）：应用的展示效果，各类UI组件</li><li>业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来</li></ul><p>而上面的这个分层的架构方案，可以用一个专业术语进行称呼：<code>MVVM</code><br>这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理。</p><h3 id="理解ViewModel"><a href="#理解ViewModel" class="headerlink" title="理解ViewModel"></a>理解ViewModel</h3><p>它的主要职责就是：</p><ul><li>数据变化后更新视图</li><li>视图变化后更新数据</li></ul><p>当然，它还有两个主要部分组成：</p><ul><li>监听器（Observer）：对所有数据的属性进行监听</li><li>解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li></ul><h2 id="实现双向绑定"><a href="#实现双向绑定" class="headerlink" title="实现双向绑定"></a>实现双向绑定</h2><p>先来看看Vue中的双向绑定流程是什么的：</p><ol><li><code>new Vue()</code>首先执行初始化，对<code>data</code>执行响应化处理，这个过程发生<code>Observe</code>中</li><li>同时对模板执行编译，找到其中动态绑定的数据，从<code>data</code>中获取并初始化视图，这个过程发生在<code>Compile</code>中</li><li>同时定义⼀个更新函数和<code>Watcher</code>，将来对应数据变化时<code>Watcher</code>会调用更新函数</li><li>由于<code>data</code>的某个<code>key</code>在⼀个视图中可能出现多次，所以每个<code>key</code>都需要⼀个管家<code>Dep</code>来管理多个<code>Watcher</code></li><li>将来<code>data</code>中数据⼀旦发生变化，会首先找到对应的<code>Dep</code>，通知所有<code>Watcher</code>执行更新函数</li></ol><p>流程图如下：<br><img src="https://img-blog.csdnimg.cn/img_convert/83f9f37a6fde9f3c4278bcb0e07112ca.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>先来一个构造函数：执行初始化，对<code>data</code>执行响应化处理</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Vue</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$options <span class="token operator">=</span> options<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$data <span class="token operator">=</span> options<span class="token punctuation">.</span>data<span class="token punctuation">;</span>              <span class="token comment">// 对data选项做响应式处理  </span>    <span class="token function">observe</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 代理data到vm上  </span>    <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 执行编译  </span>    <span class="token keyword">new</span> <span class="token class-name">Compile</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>el<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对<code>data</code>选项执行响应化具体操作</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">"object"</span> <span class="token operator">||</span> obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编译Compile"><a href="#编译Compile" class="headerlink" title="编译Compile"></a>编译<code>Compile</code></h3><p>对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</p><p><img src="https://img-blog.csdnimg.cn/img_convert/05378e819de9e8632a5e5f50fce69a43.png"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Compile</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取dom  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">compile</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> childNodes <span class="token operator">=</span> el<span class="token punctuation">.</span>childNodes<span class="token punctuation">;</span>       Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>childNodes<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 遍历子元素  </span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isElement</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 判断是否为节点  </span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"编译元素"</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>nodeName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isInterpolation</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"编译插值⽂本"</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断是否为插值文本 {{}}  </span>      <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>childNodes <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>childNodes<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 判断是否有子元素  </span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对子元素进行递归遍历  </span>      <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">isElement</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> node<span class="token punctuation">.</span>nodeType <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">isInterpolation</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> node<span class="token punctuation">.</span>nodeType <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\{\{(.*)\}\}</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>视图中会用到<code>data</code>中某<code>key</code>，这称为依赖。同⼀个<code>key</code>可能出现多次，每次都需要收集出来用⼀个<code>Watcher</code>来维护它们，此过程称为依赖收集多个<code>Watcher</code>需要⼀个<code>Dep</code>来管理，需要更新时由<code>Dep</code>统⼀通知</p><p><img src="https://img-blog.csdnimg.cn/img_convert/43db0950b0c8075c166230862cd559e0.png"></p><p>实现思路</p><ol><li><code>defineReactive</code>时为每⼀个<code>key</code>创建⼀个<code>Dep</code>实例</li><li>初始化视图时读取某个<code>key</code>，例如<code>name1</code>，创建⼀个<code>watcher1</code></li><li>由于触发<code>name1</code>的<code>getter</code>方法，便将<code>watcher1</code>添加到<code>name1</code>对应的<code>Dep</code>中</li><li>当<code>name1</code>更新，<code>setter</code>触发时，便可通过对应<code>Dep</code>通知其管理所有<code>Watcher</code>更新</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 负责更新视图  </span><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> updater</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm      <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key      <span class="token keyword">this</span><span class="token punctuation">.</span>updaterFn <span class="token operator">=</span> updater        <span class="token comment">// 创建实例时，把当前实例指定到Dep.target静态属性上  </span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>      <span class="token comment">// 读一下key，触发get  </span>    vm<span class="token punctuation">[</span>key<span class="token punctuation">]</span>      <span class="token comment">// 置空  </span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token punctuation">}</span>      <span class="token comment">// 未来执行dom更新函数，由dep调用的  </span>  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updaterFn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明<code>Dep</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 依赖管理  </span>  <span class="token punctuation">}</span>    <span class="token function">addDep</span><span class="token punctuation">(</span><span class="token parameter">dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">dep</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dep<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建<code>watcher</code>时触发<code>getter</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> updateFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>      Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依赖收集，创建<code>Dep</code>实例</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Dep<span class="token punctuation">.</span>target <span class="token operator">&amp;&amp;</span> dep<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Dep.target也就是Watcher实例  </span>      <span class="token keyword">return</span> val<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通知dep执行更新方法  </span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向数据绑定的优缺点"><a href="#双向数据绑定的优缺点" class="headerlink" title="双向数据绑定的优缺点"></a>双向数据绑定的优缺点</h2><p><strong>优点：</strong>用户在视图上的修改会自动同步到数据模型中去，数据模型中值的变化也会立刻同步到视图中去；无需进行和单向数据绑定的那些相关操作，会简化大量业务无关的代码。</p><p><strong>缺点：</strong>增加了出错时的debug的难度、消耗较大，部署很大网站的时候会出现问题。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex弹性盒子布局</title>
      <link href="/2022/08/08/flex-dan-xing-he-zi-bu-ju/"/>
      <url>/2022/08/08/flex-dan-xing-he-zi-bu-ju/</url>
      
        <content type="html"><![CDATA[<p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex元素（flex item），简称”元素”。</p><p>容器默认存在两根轴：<mark>水平的主轴（main axis）</mark>和<mark>垂直的辅轴（cross axis）</mark>，元素默认沿主轴排列。</p><p>以下6个属性设置在<strong>容器上</strong>:</p><ol><li><code>flex-direction</code>属性决定主轴的方向（即元素的排列方向）。</li><li><code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</li><li><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</li><li><code>justify-content</code>属性定义了元素在主轴上的对齐方式。 可选值：<code>flex-start</code>, <code>flex-end</code>, <code>center</code>, <code>space-around</code>, <code>space-between</code>, <code>stretch</code>。</li><li><code>align-items</code>属性定义元素在辅轴上如何对齐。 可选值：<code>flex-start</code>, <code>flex-end</code>, <code>center</code>, <code>stretch</code></li><li><code>align-content</code>属性定义了多根轴线的对齐方式。如果元素只有一根轴线，该属性不起作用。</li></ol><p>以下6个属性设置在<strong>元素上</strong>：</p><ol><li><code>order</code>属性定义元素的排列顺序。数值越小，排列越靠前，默认为0。</li><li><code>flex-grow</code>属性定义元素的增长系数，默认为0，即如果存在剩余空间，也不放大。</li><li><code>flex-shrink</code>属性定义了项目的缩减系数，默认为1，即如果空间不足，该项目将缩小。</li><li><code>flex-basis</code>属性定义了在分配多余空间之前，元素占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li><code>flex</code>属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li><code>align-self</code>属性允许单个元素有与其他元素不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 的新特性</title>
      <link href="/2022/08/08/css3-de-xin-te-xing/"/>
      <url>/2022/08/08/css3-de-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<p>圆角（<code>border-radius:8px</code>）<br>多列布局（<code>multi-column layout</code>）<br>阴影和反射（<code>Shadow\Reflect</code>）<br>文字特效（<code>text-shadow</code>）<br>文本修饰（<code>Text-decoration</code>）<br>线性渐变（<code>linear-gradient</code>）<br>旋转（<code>transform：rotate</code>）<br>缩放，平移，倾斜，动画，多背景</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>position值的定位原点</title>
      <link href="/2022/08/08/position-zhi-de-ding-wei-yuan-dian/"/>
      <url>/2022/08/08/position-zhi-de-ding-wei-yuan-dian/</url>
      
        <content type="html"><![CDATA[<p><strong><mark>absolute</mark></strong></p><p>生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。</p><p><strong><mark>fixed</mark></strong><br>生成固定定位的元素，相对于浏览器窗口进行定位。</p><p><strong><mark>relative</mark></strong></p><p>生成相对定位的元素，相对于其元素本身所在文档流中的位置进行定位。</p><p><strong><mark>static</mark></strong></p><p>默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。</p><p><strong><mark>inherit</mark></strong></p><p>规定从父元素继承position属性的值。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>display可以设置的值</title>
      <link href="/2022/08/08/display-ke-yi-she-zhi-de-zhi/"/>
      <url>/2022/08/08/display-ke-yi-she-zhi-de-zhi/</url>
      
        <content type="html"><![CDATA[<ol><li><code>block</code>：块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li><code>none</code>：元素不显示，并从文档流中移除。</li><li><code>inline</code>：行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li><li><code>inline-block</code>：默认宽度为内容宽度，可以设置宽高，同行显示。</li><li><code>list-item</code>：像块类型元素一样显示，并添加样式列表标记。</li><li><code>table</code>：此元素会作为块级表格来显示。</li><li><code>inherit</code>：规定应该从父元素继承display属性的值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何居中div</title>
      <link href="/2022/08/08/ru-he-ju-zhong-div/"/>
      <url>/2022/08/08/ru-he-ju-zhong-div/</url>
      
        <content type="html"><![CDATA[<ol><li><p>水平居中：给 div 设置一个宽度，然后添加 <code>margin:0 auto</code> 属性</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>水平居中，利用 <code>text-align:center</code> 实现</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.container</span> <span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.box</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>让绝对定位的 div 居中</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span> <span class="token comment">/*方便看效果*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li><p>水平垂直居中一</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*确定容器的宽高宽500高300的层设置层的外边距*/</span><span class="token selector">div</span><span class="token punctuation">{</span><span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span><span class="token comment">/*绝对定位*/</span><span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span><span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> -150px 0 0 -250px<span class="token punctuation">;</span><span class="token comment">/*外边距为自身宽高的一半*/</span><span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span><span class="token comment">/*方便看效果*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>水平垂直居中二</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*未知容器的宽高，利用`transform`属性*/</span><span class="token selector">div</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> <span class="token comment">/*相对定位或绝对定位均可*/</span>  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span> <span class="token comment">/*方便看效果*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>水平垂直居中三</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*利用flex布局实际使用时应考虑兼容性*/</span><span class="token selector">.container</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span> <span class="token comment">/*垂直居中*/</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span> <span class="token comment">/*水平居中*/</span><span class="token punctuation">}</span><span class="token selector">.containerdiv</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span> <span class="token comment">/*方便看效果*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>水平垂直居中四</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*利用text-align:center和vertical-align:middle属性*/</span><span class="token selector">.container</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span>  <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.container::after</span> <span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.box</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>  <span class="token property">white-space</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 中可以继承的属性</title>
      <link href="/2022/08/08/css-zhong-ke-yi-ji-cheng-de-shu-xing/"/>
      <url>/2022/08/08/css-zhong-ke-yi-ji-cheng-de-shu-xing/</url>
      
        <content type="html"><![CDATA[<p>当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应该是在该属性本身的定义中的默认值）。</p><p>当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial value（该值在该属性的概述里被指定）。</p><p>有继承性的属性：</p><ol><li><p><strong>字体系列属性</strong><br><code>font</code>、<code>font-family</code>、<code>font-weight</code>、<code>font-size</code>、<code>font-style</code>、<code>font-variant</code>、<code>font-stretch</code>、<code>font-size-adjust</code></p></li><li><p><strong>文本系列属性</strong><br><code>text-indent</code>、<code>text-align</code>、<code>text-shadow</code>、<code>line-height</code>、<code>word-spacing</code>、<code>letter-spacing</code>、<code>text-transform</code>、<code>direction</code>、<code>color</code></p></li><li><p><strong>表格布局属性</strong><br><code>caption-side</code>、<code>border-collapse</code>、<code>empty-cells</code></p></li><li><p><strong>列表属性</strong><br><code>list-style-type</code>、<code>list-style-image</code>、<code>list-style-position</code>、<code>list-style</code></p></li><li><p><strong>光标属性</strong><br><code>cursor</code></p></li><li><p><strong>元素可见性</strong><br><code>visibility</code></p></li><li><p>还有一些不常用的<br>speak，page，设置嵌套引用的引号类型quotes等属性</p></li></ol><p>注意：当一个属性不是继承属性时，可以使用<code>inherit</code>关键字指定一个属性应从父元素继承它的值，<code>inherit</code>关键字用于显式地指定继承性，可用于任何继承性/非继承性属性。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 选择器</title>
      <link href="/2022/08/08/css-xuan-ze-qi/"/>
      <url>/2022/08/08/css-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h2><ul><li>id选择器（<code>#myid</code>）</li><li>类选择器（<code>.myclassname</code>）</li><li>标签选择器（<code>div</code>,<code>h1</code>,<code>p</code>）</li><li>后代选择器（<code>h1</code>,<code>p</code>）</li><li>子选择器（<code>ul</code>&gt;<code>li</code>）</li><li>兄弟选择器（所有）（<code>li</code>~ <code>a</code>）</li><li>相邻兄弟选择器（<code>li</code>+<code>a</code>）</li><li>属性选择器（<code>a[rel="external"]</code>）</li><li>伪类选择器（<code>a:hover</code>,<code>li:nth-child</code>）</li><li>伪元素选择器（<code>::before</code>、<code>::after</code>）</li><li>通配符选择器（<code>*</code>）</li></ul><h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><p><ins>::before 和:after 中双冒号和单冒号有什么区别？</ins></p><p>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）</p><p>想让插入的内容出现在其它内容前，使用<code>::before</code>，否者，使用<code>::after</code>；<br>在代码顺序上，<code>::after</code>生成的内容也比<code>::before</code>生成的内容靠后。<br>如果按堆栈视角，<code>::after</code>生成的内容会在<code>::before</code>生成的内容之上。</p><p><ins>伪类与伪元素的区别</ins></p><p>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p><p>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过<code>:hover</code>来描述这个元素的状态。</p><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过<code>::before</code>来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p><p><ins>CSS3 新增伪类</ins></p><ol><li><code>elem:nth-child(n)</code>选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数值，也可以接受函数。</li><li><code>elem:nth-last-child(n)</code>作用同上，不过是从后开始查找。</li><li><code>elem:last-child</code>选中最后一个子元素。</li><li><code>elem:only-child</code>如果elem是父元素下唯一的子元素，则选中之。</li><li><code>elem:nth-of-type(n)</code>选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。</li><li><code>elem:first-of-type</code>选中父元素下第一个elem类型元素。</li><li><code>elem:last-of-type</code>选中父元素下最后一个elem类型元素。</li><li><code>elem:only-of-type</code>如果父元素下的子元素只有一个elem类型元素，则选中该元素。</li><li><code>elem:empty</code>选中不包含子元素和内容的elem类型元素。</li><li><code>elem:target</code>选择当前活动的elem元素。</li><li><code>:not(elem)</code>选择非elem元素的每个元素。</li><li><code>:enabled</code>控制表单控件的禁用状态。</li><li><code>:disabled</code>控制表单控件的禁用状态。</li><li><code>:checked</code>单选框或复选框被选中。</li></ol><h2 id="CSS-优先级算法"><a href="#CSS-优先级算法" class="headerlink" title="CSS 优先级算法"></a>CSS 优先级算法</h2><p>CSS的优先级是根据样式声明的特殊性值来判断的。</p><p>选择器的特殊性值分为四个等级，如下：</p><ol><li>内联样式选择器<code>x,0,0,0</code></li><li>ID选择器<code>0,x,0,0</code></li><li>class选择器/属性选择器/伪类选择器<code>0,0,x,0</code></li><li>元素和伪元素选择器<code>0,0,0,x</code></li></ol><p><i>计算方法：</i></p><ol><li>每个等级的初始值为0</li><li>每个等级的叠加为选择器出现的次数相加</li><li>不可进位，比如0,99,99,99</li><li>依次表示为：0,0,0,0</li><li>每个等级计数之间没关联</li><li>等级判断从左向右，如果某一位数值相同，则判断下一位数值</li><li>如果两个优先级相同，则最后出现的优先级高，!important也适用</li><li>通配符选择器的特殊性值为：0,0,0,0</li><li>继承样式优先级最低，通配符样式优先级高于继承样式</li><li><code>!important</code>（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0</li></ol><p>注意：</p><ol><li>样式应用时，css会先查看规则的权重<code>!important</code>，加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。</li><li>特殊性值越大的声明优先级越高。</li><li>相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）。</li><li>部分浏览器由于字节溢出问题出现的进位表现不做考虑。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 的盒子模型</title>
      <link href="/2022/08/08/css-de-he-zi-mo-xing/"/>
      <url>/2022/08/08/css-de-he-zi-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>盒模型：分为<strong>内容（content）、填充（padding）、边界（margin）、边框（border）</strong>四个部分</p><p>有两种盒子模型：</p><ul><li>IE盒模型（border-box）</li><li>W3C标准盒模型（content-box）</li></ul><p>IE盒模型和W3C标准盒模型的区别：</p><ol><li>W3C标准盒模型：属性width，height只包含内容<mark>content</mark>，不包含border和padding。</li><li>IE盒模型：属性width，height包含content、border和padding，指的是<mark>content+padding+border</mark>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="/2022/08/07/qian-duan-xing-neng-you-hua/"/>
      <url>/2022/08/07/qian-duan-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<p>前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。可以从这些方面来进行优化。</p><p><em>第一个方面是页面的内容方面：</em></p><ol><li>通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。</li><li>通过 DNS 缓存等机制来减少 DNS 的查询次数。</li><li>通过设置缓存策略，对常用不变的资源进行缓存。</li><li>使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。</li><li>通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。</li></ol><p><em>第二个方面是服务器方面:</em></p><ol><li>使用 CDN 服务，来提高用户对于资源请求时的响应速度。</li><li>服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。</li><li>尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie。</li></ol><p><em>第三个方面是 CSS 和 JavaScript 方面:</em></p><ol><li>把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。</li><li>避免使用 <code>@import</code> 标签。</li><li>尽量把 js 脚本放在页面底部或者使用 <code>defer</code> 或 <code>async</code> 属性，避免脚本的加载和执行阻塞页面的渲染。</li><li>通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>head中的标签</title>
      <link href="/2022/08/07/head-zhong-de-biao-qian/"/>
      <url>/2022/08/07/head-zhong-de-biao-qian/</url>
      
        <content type="html"><![CDATA[<p><code>&lt;head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器。<code>&lt;head&gt;</code> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</p><p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<code>&lt;base&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code>, 以及 <code>&lt;title&gt;</code>。</p><p><code>&lt;title&gt;</code> 定义文档的标题，它是 <strong>head 部分中唯一必需的元素</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器架构</title>
      <link href="/2022/08/06/liu-lan-qi-jia-gou/"/>
      <url>/2022/08/06/liu-lan-qi-jia-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2><p>浏览器本质上也是一个软件，它运行于操作系统之上，一般来说会在特定的一个端口开启一个进程去运行这个软件，开启进程之后，计算机为这个进程分配CPU资源、运行时内存，磁盘空间以及网络资源等等，通常会为其指定一个PID来代表它。</p><p>浏览器分为两种架构：</p><ul><li>单进程架构（线程间通信）</li><li>多进程架构（进程间IPC通信）</li></ul><p>如果<strong>浏览器单进程架构的话，需要在一个进程内做到网络、调度、UI、存储、GPU、设备、渲染、插件等等任务</strong>，通常来说可以为每个任务开启一个线程，形成单进程多线程的浏览器架构。</p><p>但是由于这些功能的日益复杂，例如将网络，存储，UI放在一个线程中的话，执行效率和性能越来越低下，不能再向下拆分出类似“线程”的子空间。</p><p>因此，<strong>为了逐渐强化浏览器的功能，于是产生了多进程架构的浏览器，可以将网络、调度、UI、存储、GPU、设备、渲染、插件等等任务分配给多个单独的进程，在每一个单独的进程内，又可以拆分出多个子线程，极大程度地强化了浏览器。</strong></p><p>Chrome多进程架构主要包括以下4个进程：</p><ul><li>Browser进程（负责地址栏、书签栏、前进后退、网络请求、文件访问等）</li><li>Renderer进程（负责一个Tab内所有和网页渲染有关的所有事情，是最核心的进程）</li><li>GPU进程（负责GPU相关的任务）</li><li>Plugin进程（负责Chrome插件相关的任务）</li></ul><p>Chrome 多进程架构的优缺点<br><mark>优点：</mark></p><ul><li>每一个Tab就是要给单独的进程</li><li>由于每个Tab都有自己独立的Renderer进程，因此某一个Tab出问题不会影响其它Tab</li></ul><p><mark>缺点：</mark></p><ul><li>Tab间内存不共享，不同进程内存包含相同内容</li></ul><p>前端最核心的渲染（Renderer）进程包含4个线程：</p><ul><li><strong>主线程（Main thread）(下载资源、执行js、计算样式、进行布局、绘制合成)</strong><ul><li>下载资源：主线程可以通过Browser进程的network线程下载图片，css，js等渲染DOM需要的资源文件。</li><li>执行JS：<strong>主线程在遇到<code>&lt;script&gt;</code>标签时，会下载并且执行js，执行js时，为了避免改变DOM的结构，解析HTML停滞，js执行完成后继续解析HTML。正是因为JS执行会阻塞UI渲染，而JS又是浏览器的一哥，因此浏览器常常被看做是单线程的。</strong></li><li>计算样式：主线程会基于CSS选择器或者浏览器默认样式去进行样式计算，最终生成Computed Style。</li><li>进行布局：主线程计算好样式以后，可以确定元素的位置信息以及盒模型信息，对元素进行布局。</li><li>进行绘制：主线程根据先后顺序以及层级关系对元素进行渲染，通常会生成多个图层。</li><li>最终合成：主线程将渲染后的多个frame（帧）合成，类似flash的帧动画和PS的图层。</li></ul></li><li>光栅线程（Raster thread）</li><li>合成线程（Compositor thread）</li><li>工作线程（Worker thread）</li></ul><p><img src="https://s2.loli.net/2022/08/06/yCJ1adtHSZQiBjW.png" alt="渲染进程包含的4个线程"></p><h2 id="单线程js"><a href="#单线程js" class="headerlink" title="单线程js"></a>单线程js</h2><p><em>Chrome中JavaScript运行的位置在哪里呢？</em><br><strong>渲染进程（Renderer Process）中的主线程（Main Thread）</strong></p><p><em>单线程js属于浏览器的哪个进程？</em><br>单线程的js → 主线程（Main Thread）→ <strong>渲染进程（Renderer Process）</strong></p><p><em>js为什么要设计成单线程的？</em><br>其实更为严谨的表述是：“浏览器中的js执行和UI渲染是在一个线程中顺序发生的。”<br>这是因为在渲染进程的主线程在解析HTML生成DOM树的过程中，如果此时执行JS，主线程会主动暂停解析HTML，先去执行JS，等JS解析完成后，再继续解析HTML。</p><p><em>那么为什么要“主线程会主动暂停解析HTML，先去执行JS，再继续解析HTML呢”？</em></p><p><strong>这是主线程在解析HTML生成DOM树的过程中会执行<code>style</code>，<code>layout</code>，<code>render</code>以及<code>composite</code>的操作，而JS可以操作DOM，CSSOM，会影响到主线程在解析HTML的最终渲染结果，最终页面的渲染结果将变得不可预见。</strong></p><p>如果主线程一边解析HTML进行渲染，JS同时在操作DOM或者CSSOM，结果会分为以下情况：</p><ul><li>以主线程解析HTML的渲染结果为准</li><li>以JS同时在操作DOM或者CSSOM的渲染结果为准</li></ul><p>考虑到最终页面的渲染效果的一致性，所以js在浏览器中的实现，被设计成为了JS执行阻塞UI渲染型。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环可以拆为“事件”+“循环”。</p><p>先来聊聊“事件”：</p><ul><li>click、mouseover等等交互事件</li><li>事件冒泡、事件捕获、事件委托等等</li><li>addEventListener、removeEventListener()</li><li>CustomEvent（自定义事件实现自定义交互）</li><li>EventEmitter、EventBus（on，emit，once，off）</li><li>第三方库的事件系统</li></ul><p>有事件，就有<strong>事件处理器</strong>：在事件处理器中，我们会应对这个事件做一些特殊操作。</p><p>如果我们的主线程只是静态的，没有循环的话，可以用js伪代码将其表述为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hello World！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hello JavaScript！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行完一次mainThread()之后，这段代码就无效了，mainThread并不是一种激活状态，对于I/O事件是没有办法捕获到的。</p><p>因此对事件加入了“循环”，将渲染进程的主线程变为激活状态，可以用js伪代码表述如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// click event</span><span class="token keyword">function</span> <span class="token function">clickTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"我点击按钮了"</span><span class="token punctuation">}</span><span class="token comment">// 可以是while循环</span><span class="token keyword">function</span> <span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">clickTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>“通知click事件监听器”<span class="token punctuation">)</span> <span class="token punctuation">}</span>        clickTrigger <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以是for循环：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">clickTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>“通知click事件监听器”<span class="token punctuation">)</span> <span class="token punctuation">}</span>    clickTrigger <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在事件监听器中做出响应：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"多亏了事件循环，我（浏览器）才能知道用户做了什么操作"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列可以拆为“消息”+“队列”。 消息可以理解为用户I/O；队列就是先进先出的数据结构。 而消息队列，则是用于连接用户I/O与事件循环的桥梁。</p><p><strong>队列数据结构图</strong></p><p><img src="https://s2.loli.net/2022/08/06/mUBnAaTzV17hQb5.png" alt="队列数据结构图"></p><p><strong>入队出队图</strong></p><p><img src="https://s2.loli.net/2022/08/06/orNHakKW6p7RFi5.png" alt="入队出队图"></p><p><em>在js中，如何发现出队列FIFO的特性？</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 定义一个队列</span><span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 入队</span>queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// queue[1,2,3,4]</span><span class="token comment">// 出队</span>queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 queue [2,3,4]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设用户做出了”click button1”,”click button3”,”click button 2”的操作。 事件队列定义为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> taskQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"click button1"</span><span class="token punctuation">,</span><span class="token string">"click button3"</span><span class="token punctuation">,</span><span class="token string">"click button 2"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">.</span>length<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    taskQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 任务依次出队</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>任务依次出队： <code>click button1</code> <code>click button3</code> <code>click button 2</code></p><p>此时由于mainThread有事件循环，它会被浏览器渲染进程的主线程事件循环系统捕获，并在对应的事件处理器做出响应。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">button1<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click button1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>button2<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click button 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>button3<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click button3"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依次打印：”click button1”，”click button3”，”click button 2”。</p><p>因此，<strong>可以将消息队列理解为连接用户I/O操作和浏览器事件循环系统的任务队列。</strong></p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p><strong>宏任务</strong></p><p>(macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p><p><strong>微任务</strong></p><p>microtask,可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。</p><h3 id="哪些属于宏任务？"><a href="#哪些属于宏任务？" class="headerlink" title="哪些属于宏任务？"></a>哪些属于宏任务？</h3><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>requestAnimationFrame</li><li>I/O</li><li>UI渲染</li></ul><h3 id="哪些属于微任务？"><a href="#哪些属于微任务？" class="headerlink" title="哪些属于微任务？"></a>哪些属于微任务？</h3><ul><li>Promise</li><li>MutationObserver</li><li>process.nextTick</li><li>queueMicrotask</li></ul><h2 id="事件循环，消息队列与宏任务、微任务之间的关系"><a href="#事件循环，消息队列与宏任务、微任务之间的关系" class="headerlink" title="事件循环，消息队列与宏任务、微任务之间的关系"></a>事件循环，消息队列与宏任务、微任务之间的关系</h2><ul><li>宏任务入队消息队列，可以将消息队列理解为宏任务队列</li><li>每个宏任务内有一个微任务队列，执行过程中微任务入队当前宏任务的微任务队列</li><li>宏任务微任务队列为空时才会执行下一个宏任务</li><li>事件循环捕获队列出队的宏任务和微任务并执行</li></ul><p>事件循环会不断地处理消息队列出队的任务，而宏任务指的就是入队到消息队列中的任务，每个宏任务都有一个微任务队列，宏任务在执行过程中，如果此时产生微任务，那么会将产生的微任务入队到当前的微任务队列中，在当前宏任务的主要任务完成后，会依次出队并执行微任务队列中的任务，直到当前微任务队列为空才会进行下一个宏任务。</p><p><strong>浏览器页面循环系统原理图</strong></p><p><i>消息队列和事件循环</i></p><p>线程的一次执行</p><p><img src="https://s2.loli.net/2022/08/06/MoLs4SiYWHwUxZn.png"></p><p>在线程中引入事件循环</p><p><img src="https://s2.loli.net/2022/08/06/8dKcb7FCwZuaeSW.png"></p><p>渲染进程线程之间发送任务</p><p><img src="https://pic3.zhimg.com/80/v2-8d1b124eb3f15d00599bc377b72d5aba_720w.jpg"><br><img src="https://pic4.zhimg.com/80/v2-1c8a495a5cb1f6b22cd3c742da90aafb_720w.jpg"></p><p>线程模型：队列 + 循环</p><p><img src="https://pic3.zhimg.com/80/v2-7802282fcaaaf814c95b2bafb656e982_720w.jpg"></p><p>跨进程发送消息</p><p><img src="https://pic1.zhimg.com/80/v2-9549cf89a6557150edf1b9ed6ed27274_720w.jpg"></p><p>单个任务执行时间过久</p><p><img src="https://pic4.zhimg.com/80/v2-4874dbf5343d2612b4785366a99c4ffb_720w.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器内多个标签页之间的通信</title>
      <link href="/2022/08/05/liu-lan-qi-nei-duo-ge-biao-qian-ye-zhi-jian-de-tong-xin/"/>
      <url>/2022/08/05/liu-lan-qi-nei-duo-ge-biao-qian-ye-zhi-jian-de-tong-xin/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用 <code>WebSocket</code>，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。<br> <code>WebSocket</code>特点：</p><ul><li>保持连接状态，HTTP协议是无状态连接，即请求完毕后就会关闭连接；</li><li>全双工通信，客户端和服务端平等对待，可以互相通信；</li><li>建立在TCP协议之上；</li><li>没有同源共享策略，即可实现跨域共享。</li></ul></li><li><p>使用 <code>SharedWorker</code> （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。</p></li><li><p>可以调用 <code>localStorage</code>、<code>cookies</code> 等本地存储方式，<code>localStorge</code> 另一个浏览上下文里被添加、修改或删除时，它都会触发一个 <code>storage</code> 事件，我们通过监听 <code>storage</code> 事件，控制它的值来进行页面信息通信。<br><code>localStorage</code>特点：</p><ul><li>同域共享存储空间；</li><li>持久化将数据存储在浏览器；</li><li>提供事件监听<code>localStorage</code>变化。</li></ul></li><li><p>如果我们能够获得对应标签页的引用，通过 <code>postMessage</code> 方法也是可以实现多个标签页通信的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Label 标签的作用</title>
      <link href="/2022/08/05/label-biao-qian-de-zuo-yong/"/>
      <url>/2022/08/05/label-biao-qian-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<p><code>label</code> 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Number:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“text“</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iframe 的缺点</title>
      <link href="/2022/08/05/iframe-de-que-dian/"/>
      <url>/2022/08/05/iframe-de-que-dian/</url>
      
        <content type="html"><![CDATA[<p><code>iframe</code> 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><h2 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h2><ol><li><code>iframe</code> 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 <code>iframe</code> 的 <code>src</code> 可以避免这种阻塞情况。</li><li>搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。</li><li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li><li>浏览器的后退按钮失效。</li><li>小型的移动设备无法完全显示框架。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookies，sessionStorage 和 localStorage 的区别</title>
      <link href="/2022/08/05/cookies-sessionstorage-he-localstorage-de-qu-bie/"/>
      <url>/2022/08/05/cookies-sessionstorage-he-localstorage-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><code>SessionStorage</code>， <code>LocalStorage</code>， <code>Cookie</code> 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别在于前两者属于 HTML5 WebStorage，创建它们的目的是便于客户端存储数据。而 <code>cookie</code> 是网站为了标示用户身份而储存用户本地终端上的数据（通常经过加密）。<code>cookie</code> 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不要），会在浏览器和服务器间来回传递。</p><table><thead><tr><th></th><th>区别</th></tr></thead><tbody><tr><td>存储大小</td><td><code>cookie</code> 数据大小不能超过 4k。<br><code>sessionStorage</code> 和 <code>localStorage</code> 虽然也有存储大小的限制，但比 <code>cookie</code> 大得多，可以达到 5M 或更大。</td></tr><tr><td>有效时间</td><td><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。<br> <code>sessionStorage</code> 数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。<br><code>cookie</code> 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</td></tr><tr><td>作用域</td><td><code>sessionStorage</code>  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。<br><code>localStorage</code> 在所有同源窗口中都是共享的。<br><code>cookie</code> 在所有同源窗口中都是共享的。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 语义化</title>
      <link href="/2022/08/05/html-yu-yi-hua/"/>
      <url>/2022/08/05/html-yu-yi-hua/</url>
      
        <content type="html"><![CDATA[<ol><li>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；</li><li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的；</li><li>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO（搜索引擎优化）；</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5的新特性</title>
      <link href="/2022/08/05/html5-de-xin-te-xing/"/>
      <url>/2022/08/05/html5-de-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><ul><li>画布： <code>canvas</code>;</li><li>音视频： <code>video</code> 和 <code>audio</code> 元素;</li><li>web存储：本地离线存储 <code>localStorage</code> 长期存储数据，浏览器关闭后数据不丢失；<code>sessionStorage</code> 的数据在浏览器关闭后自动删除;</li><li>语义化更好的内容元素，比如 <code>article</code>、<code>footer</code>、<code>header</code>、<code>main</code>、<code>nav</code>、<code>section</code>;</li><li>表单控件，<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code>;</li><li>新的技术 <code>webworker</code>， <code>websocket</code>；</li><li>新的文档属性 <code>document.visibilityState</code>。</li></ul><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><ul><li>纯表现的元素：<code>basefont</code>，<code>big</code>，<code>center</code>，<code>font</code>, <code>s</code>，<code>strike</code>，<code>tt</code>，<code>u</code>;</li><li>对可用性产生负面影响的元素：<code>frame</code>，<code>frameset</code>，<code>noframes</code>；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重绘和重排（回流）</title>
      <link href="/2022/08/05/chong-hui-he-chong-pai-hui-liu/"/>
      <url>/2022/08/05/chong-hui-he-chong-pai-hui-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 <code>background-color</code>，这样的操作称为<mark>重绘</mark>。</p><h2 id="重排（回流）"><a href="#重排（回流）" class="headerlink" title="重排（回流）"></a>重排（回流）</h2><p>当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作称为<mark>回流</mark>。</p><br><ins>一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</ins><h3 id="常见引起回流属性和方法"><a href="#常见引起回流属性和方法" class="headerlink" title="常见引起回流属性和方法"></a>常见引起回流属性和方法</h3><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p><ol><li>添加或者删除可见的 DOM 元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度；</li><li>内容变化，比如用户在 input 框中输入文字；</li><li>浏览器窗口尺寸改变——resize事件发生时；</li><li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性；</li><li>设置 <code>style</code> 属性的值；</li><li>修改网页的默认字体时。</li></ol><p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong>回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><p><em>常见引起重绘属性和方法：</em><br><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-14.png" alt="常见引起回流属性和方法"></p><p><em>常见引起回流属性和方法：</em><br><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-13.png" alt="常见引起重绘属性和方法"></p><h3 id="如何减少回流？"><a href="#如何减少回流？" class="headerlink" title="如何减少回流？"></a>如何减少回流？</h3><ol><li>使用 <code>transform</code> 替代 <code>top</code>；</li><li>不要把节点的属性值放在一个循环里当成循环里的变量；</li><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局；</li><li>把 DOM 离线后修改。如：使用 <code>documentFragment</code> 对象在内存里操作 DOM；</li><li>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 <code>class</code>，然后修改 DOM 的 <code>className</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器解析过程</title>
      <link href="/2022/08/04/liu-lan-qi-jie-xi-guo-cheng/"/>
      <url>/2022/08/04/liu-lan-qi-jie-xi-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>在浏览器渲染过程当中，遇到<code>JavaScript</code> 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 <code>JavaScript</code>，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p><p>也就是说，如果我们想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为我们可以给 script 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</p><br><p>js脚本没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>defer</td><td>表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</td></tr><tr><td>async</td><td>表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</td></tr></tbody></table><p><img src="/../images/defer%E3%80%81async%E5%8C%BA%E5%88%AB.png" alt="defer、async区别"></p><p><strong>文档的预解析:</strong><br> Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p><p><strong>CSS 如何阻塞文档解析？</strong><br>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 <code>CSSOM</code> 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 <code>CSSOM</code>，然后再执行 JavaScript，最后再继续文档的解析。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的渲染原理</title>
      <link href="/2022/08/04/liu-lan-qi-de-xuan-ran-yuan-li/"/>
      <url>/2022/08/04/liu-lan-qi-de-xuan-ran-yuan-li/</url>
      
        <content type="html"><![CDATA[<ol><li>首先解析收到的文档，根据文档定义构建一棵 <code>DOM 树</code>，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成 <code>CSSOM 规则树</code>。</li><li>根据 <code>DOM 树</code>和 <code>CSSOM 规则树</code>构建渲染树。渲染树的节点被称为<mark>渲染对象</mark>，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做<mark>回流</mark>）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动<mark>重排</mark>”。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ol><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器内核的理解</title>
      <link href="/2022/08/04/liu-lan-qi-nei-he-de-li-jie/"/>
      <url>/2022/08/04/liu-lan-qi-nei-he-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p>主要分成两部分：<code>渲染引擎</code>和<code>JS引擎</code>。<br><code>渲染引擎</code>的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。<br><code>JS引擎</code>：解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。<br><br><br><strong>常见的浏览器内核比较</strong></p><table><thead><tr><th>浏览器内核名称</th><th>简介</th></tr></thead><tbody><tr><td>Gecko</td><td>这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</td></tr><tr><td>Presto</td><td>Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</td></tr><tr><td>Webkit</td><td>Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</td></tr><tr><td>Blink</td><td>谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行内元素与块级元素</title>
      <link href="/2022/08/03/xing-nei-yuan-su-yu-kuai-ji-yuan-su/"/>
      <url>/2022/08/03/xing-nei-yuan-su-yu-kuai-ji-yuan-su/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th></th><th>定义</th><th>常用元素</th></tr></thead><tbody><tr><td>行内元素</td><td>一个行内元素只占据它对应标签的边框所包含的空间。<ins>（没有宽高）</ins></td><td><code>a</code> <code>b</code> <code>span</code> <code>img</code> <code>strong</code> <code>sub</code> <code>sup</code> <code>button</code> <code>input</code> <code>label</code> <code>select</code> <code>textarea</code></td></tr><tr><td>块级元素</td><td>块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。</td><td><code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code> <code>h3</code> <code>h4</code> <code>h5</code> <code>h6</code> <code>p</code></td></tr></tbody></table><br><strong>两者区别：</strong><br>1. <mark>格式上</mark>，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。<br>2. <mark>内容上</mark>，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。<br>3. 行内元素与块级元素属性的不同，主要是盒模型属性上：<mark>行内元素</mark>不支持设置宽高；<mark>行内元素</mark>支持水平方向的padding、border、margin；行内元素可以设置垂直方向的padding、border、margin，但是不会影响布局。<br><br><strong>行内块元素：</strong><p>通过<code>display:inline-block</code>设置，既有行内元素的特点也有块级元素的特点：<br>1.可以改变宽高（块级元素特点）<br>2.不独立成行（行内元素特点）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SGML 、 HTML 、XML 和 XHTML 的区别</title>
      <link href="/2022/08/03/sgml-html-xml-he-xhtml-de-qu-bie/"/>
      <url>/2022/08/03/sgml-html-xml-he-xhtml-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><mark>SGML</mark> 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。<br><br><br><mark>HTML</mark> 是超文本标记语言，主要是用于规定怎么显示网页。<br><br><br><mark>XML</mark> 是可扩展标记语言，是未来网页语言的发展方向。<br><br><br><ins><mark>XML</mark> 和 <mark>HTML</mark> 的最大区别就在于 <mark>XML</mark> 的标签是可以自己创建的，数量无限多,而 <mark>HTML</mark> 的标签都是固定的而且数量有限。</ins><br><br><br><mark>XHTML</mark> 也是现在基本上所有网页都在用的标记语言，他其实和 <mark>HTML</mark> 没什么本质的区别，标签都一样，用法也都一样，就是比 <mark>HTML</mark> 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Front-matter选项作用</title>
      <link href="/2022/08/03/front-matter-xuan-xiang-zuo-yong/"/>
      <url>/2022/08/03/front-matter-xuan-xiang-zuo-yong/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><mark>Markdown</mark> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根据 <mark>_config.yml</mark> 中的 author</td><td>文章作者</td></tr><tr><td>img</td><td><mark>eatureImages</mark> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <mark><a href="http://xxx.com/xxx.jpg">http://xxx.com/xxx.jpg</a></mark></td></tr><tr><td>top</td><td><mark>true</mark></td><td>推荐文章（文章是否置顶），如果 top 值为 <mark>true</mark>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><mark>false</mark></td><td>隐藏文章，如果hide值为true，则文章不会在首页显示</td></tr><tr><td>cover</td><td><mark>false</mark></td><td><mark>v1.0.2</mark>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><mark>v1.0.2</mark>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <mark>password</mark> 的值，该值必须是用 <mark>SHA256</mark> 加密后的密码，防止被他人识破。前提是在主题的 <mark>config.yml</mark> 中激活了 <mark>verifyPassword</mark> 选项</td></tr><tr><td>toc</td><td>true</td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <mark>config.yml</mark> 中激活了 toc 选项</td></tr><tr><td>mathjax</td><td><mark>false</mark></td><td>是否开启数学公式支持 ，本文章是否开启 <mark>mathjax</mark>，且需要在主题的 <mark>_config.yml</mark> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><br><p><a href="https://blog.17lai.site/posts/cf0f47fd">Hexo Markdown以及各种插件功能测试</a></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOCTYPE的作用</title>
      <link href="/2022/08/02/doctype-de-zuo-yong/"/>
      <url>/2022/08/02/doctype-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<p><big>相关知识点:</big><br>IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的<br><mark>&lt;!DOCTYPE&gt;</mark>声明位于HTML文档中的第一行，处于<mark>html</mark>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<br>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</p><p><mark>&lt;!DOCTYPE&gt;</mark>声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。<br>在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。<br>在<mark>html5</mark>之后不再需要指定 DTD 文档，因为<mark>html5</mark>以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而<mark>html5</mark>不再基于 SGML 了，所以不再需要使用 DTD。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
