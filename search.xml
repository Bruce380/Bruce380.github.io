<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器解析过程</title>
      <link href="/2022/08/04/liu-lan-qi-jie-xi-guo-cheng/"/>
      <url>/2022/08/04/liu-lan-qi-jie-xi-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>在浏览器渲染过程当中，遇到<code>JavaScript</code> 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 <code>JavaScript</code>，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p><p>也就是说，如果我们想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为我们可以给 script 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</p><br><p>js脚本没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>defer</td><td>表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</td></tr><tr><td>async</td><td>表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</td></tr></tbody></table><p><img src="/../images/defer%E3%80%81async%E5%8C%BA%E5%88%AB.png" alt="defer、async区别"></p><p><strong>文档的预解析:</strong><br> Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p><p><strong>CSS 如何阻塞文档解析？</strong><br>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 <code>CSSOM</code> 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 <code>CSSOM</code>，然后再执行 JavaScript，最后再继续文档的解析。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的渲染原理</title>
      <link href="/2022/08/04/liu-lan-qi-de-xuan-ran-yuan-li/"/>
      <url>/2022/08/04/liu-lan-qi-de-xuan-ran-yuan-li/</url>
      
        <content type="html"><![CDATA[<ol><li>首先解析收到的文档，根据文档定义构建一棵 <code>DOM 树</code>，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成 <code>CSSOM 规则树</code>。</li><li>根据 <code>DOM 树</code>和 <code>CSSOM 规则树</code>构建渲染树。渲染树的节点被称为<mark>渲染对象</mark>，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做<mark>回流</mark>）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动<mark>重排</mark>”。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ol><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器内核的理解</title>
      <link href="/2022/08/04/liu-lan-qi-nei-he-de-li-jie/"/>
      <url>/2022/08/04/liu-lan-qi-nei-he-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p>主要分成两部分：<code>渲染引擎</code>和<code>JS引擎</code>。<br><code>渲染引擎</code>的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。<br><code>JS引擎</code>：解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。<br><br><br><strong>常见的浏览器内核比较</strong></p><table><thead><tr><th>浏览器内核名称</th><th>简介</th></tr></thead><tbody><tr><td>Gecko</td><td>这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</td></tr><tr><td>Presto</td><td>Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</td></tr><tr><td>Webkit</td><td>Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</td></tr><tr><td>Blink</td><td>谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行内元素与块级元素</title>
      <link href="/2022/08/03/xing-nei-yuan-su-yu-kuai-ji-yuan-su/"/>
      <url>/2022/08/03/xing-nei-yuan-su-yu-kuai-ji-yuan-su/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th></th><th>定义</th><th>常用元素</th></tr></thead><tbody><tr><td>行内元素</td><td>一个行内元素只占据它对应标签的边框所包含的空间。<ins>（没有宽高）</ins></td><td><code>a</code> <code>b</code> <code>span</code> <code>img</code> <code>strong</code> <code>sub</code> <code>sup</code> <code>button</code> <code>input</code> <code>label</code> <code>select</code> <code>textarea</code></td></tr><tr><td>块级元素</td><td>块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。</td><td><code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code> <code>h3</code> <code>h4</code> <code>h5</code> <code>h6</code> <code>p</code></td></tr></tbody></table><br><strong>两者区别：</strong><br>1. <mark>格式上</mark>，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。<br>2. <mark>内容上</mark>，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。<br>3. 行内元素与块级元素属性的不同，主要是盒模型属性上：<mark>行内元素</mark>不支持设置宽高；<mark>行内元素</mark>支持水平方向的padding、border、margin；行内元素可以设置垂直方向的padding、border、margin，但是不会影响布局。<br><br><strong>行内块元素：</strong><p>通过<code>display:inline-block</code>设置，既有行内元素的特点也有块级元素的特点：<br>1.可以改变宽高（块级元素特点）<br>2.不独立成行（行内元素特点）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SGML 、 HTML 、XML 和 XHTML 的区别</title>
      <link href="/2022/08/03/sgml-html-xml-he-xhtml-de-qu-bie/"/>
      <url>/2022/08/03/sgml-html-xml-he-xhtml-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><mark>SGML</mark> 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。<br><br><br><mark>HTML</mark> 是超文本标记语言，主要是用于规定怎么显示网页。<br><br><br><mark>XML</mark> 是可扩展标记语言，是未来网页语言的发展方向。<br><br><br><ins><mark>XML</mark> 和 <mark>HTML</mark> 的最大区别就在于 <mark>XML</mark> 的标签是可以自己创建的，数量无限多,而 <mark>HTML</mark> 的标签都是固定的而且数量有限。</ins><br><br><br><mark>XHTML</mark> 也是现在基本上所有网页都在用的标记语言，他其实和 <mark>HTML</mark> 没什么本质的区别，标签都一样，用法也都一样，就是比 <mark>HTML</mark> 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Front-matter选项作用</title>
      <link href="/2022/08/03/front-matter-xuan-xiang-zuo-yong/"/>
      <url>/2022/08/03/front-matter-xuan-xiang-zuo-yong/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><mark>Markdown</mark> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根据 <mark>_config.yml</mark> 中的 author</td><td>文章作者</td></tr><tr><td>img</td><td><mark>eatureImages</mark> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <mark><a href="http://xxx.com/xxx.jpg">http://xxx.com/xxx.jpg</a></mark></td></tr><tr><td>top</td><td><mark>true</mark></td><td>推荐文章（文章是否置顶），如果 top 值为 <mark>true</mark>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><mark>false</mark></td><td>隐藏文章，如果hide值为true，则文章不会在首页显示</td></tr><tr><td>cover</td><td><mark>false</mark></td><td><mark>v1.0.2</mark>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><mark>v1.0.2</mark>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <mark>password</mark> 的值，该值必须是用 <mark>SHA256</mark> 加密后的密码，防止被他人识破。前提是在主题的 <mark>config.yml</mark> 中激活了 <mark>verifyPassword</mark> 选项</td></tr><tr><td>toc</td><td>true</td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <mark>config.yml</mark> 中激活了 toc 选项</td></tr><tr><td>mathjax</td><td><mark>false</mark></td><td>是否开启数学公式支持 ，本文章是否开启 <mark>mathjax</mark>，且需要在主题的 <mark>_config.yml</mark> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><br><p><a href="https://blog.17lai.site/posts/cf0f47fd">Hexo Markdown以及各种插件功能测试</a></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOCTYPE的作用</title>
      <link href="/2022/08/02/doctype-de-zuo-yong/"/>
      <url>/2022/08/02/doctype-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<p><big>相关知识点:</big><br>IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的<br><mark>&lt;!DOCTYPE&gt;</mark>声明位于HTML文档中的第一行，处于<mark>html</mark>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<br>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</p><p><mark>&lt;!DOCTYPE&gt;</mark>声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。<br>在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。<br>在<mark>html5</mark>之后不再需要指定 DTD 文档，因为<mark>html5</mark>以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而<mark>html5</mark>不再基于 SGML 了，所以不再需要使用 DTD。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
