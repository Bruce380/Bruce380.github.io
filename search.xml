<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器架构</title>
      <link href="/2022/08/06/liu-lan-qi-jia-gou/"/>
      <url>/2022/08/06/liu-lan-qi-jia-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2><p>浏览器本质上也是一个软件，它运行于操作系统之上，一般来说会在特定的一个端口开启一个进程去运行这个软件，开启进程之后，计算机为这个进程分配CPU资源、运行时内存，磁盘空间以及网络资源等等，通常会为其指定一个PID来代表它。</p><p>浏览器分为两种架构：</p><ul><li>单进程架构（线程间通信）</li><li>多进程架构（进程间IPC通信）</li></ul><p>如果<strong>浏览器单进程架构的话，需要在一个进程内做到网络、调度、UI、存储、GPU、设备、渲染、插件等等任务</strong>，通常来说可以为每个任务开启一个线程，形成单进程多线程的浏览器架构。</p><p>但是由于这些功能的日益复杂，例如将网络，存储，UI放在一个线程中的话，执行效率和性能越来越低下，不能再向下拆分出类似“线程”的子空间。</p><p>因此，<strong>为了逐渐强化浏览器的功能，于是产生了多进程架构的浏览器，可以将网络、调度、UI、存储、GPU、设备、渲染、插件等等任务分配给多个单独的进程，在每一个单独的进程内，又可以拆分出多个子线程，极大程度地强化了浏览器。</strong></p><p>Chrome多进程架构主要包括以下4个进程：</p><ul><li>Browser进程（负责地址栏、书签栏、前进后退、网络请求、文件访问等）</li><li>Renderer进程（负责一个Tab内所有和网页渲染有关的所有事情，是最核心的进程）</li><li>GPU进程（负责GPU相关的任务）</li><li>Plugin进程（负责Chrome插件相关的任务）</li></ul><p>Chrome 多进程架构的优缺点<br><mark>优点：</mark></p><ul><li>每一个Tab就是要给单独的进程</li><li>由于每个Tab都有自己独立的Renderer进程，因此某一个Tab出问题不会影响其它Tab</li></ul><p><mark>缺点：</mark></p><ul><li>Tab间内存不共享，不同进程内存包含相同内容</li></ul><p>前端最核心的渲染（Renderer）进程包含4个线程：</p><ul><li><strong>主线程（Main thread）(下载资源、执行js、计算样式、进行布局、绘制合成)</strong><ul><li>下载资源：主线程可以通过Browser进程的network线程下载图片，css，js等渲染DOM需要的资源文件。</li><li>执行JS：<strong>主线程在遇到<code>&lt;script&gt;</code>标签时，会下载并且执行js，执行js时，为了避免改变DOM的结构，解析HTML停滞，js执行完成后继续解析HTML。正是因为JS执行会阻塞UI渲染，而JS又是浏览器的一哥，因此浏览器常常被看做是单线程的。</strong></li><li>计算样式：主线程会基于CSS选择器或者浏览器默认样式去进行样式计算，最终生成Computed Style。</li><li>进行布局：主线程计算好样式以后，可以确定元素的位置信息以及盒模型信息，对元素进行布局。</li><li>进行绘制：主线程根据先后顺序以及层级关系对元素进行渲染，通常会生成多个图层。</li><li>最终合成：主线程将渲染后的多个frame（帧）合成，类似flash的帧动画和PS的图层。</li></ul></li><li>光栅线程（Raster thread）</li><li>合成线程（Compositor thread）</li><li>工作线程（Worker thread）</li></ul><p><img src="https://s2.loli.net/2022/08/06/yCJ1adtHSZQiBjW.png" alt="渲染进程包含的4个线程"></p><h2 id="单线程js"><a href="#单线程js" class="headerlink" title="单线程js"></a>单线程js</h2><p><em>Chrome中JavaScript运行的位置在哪里呢？</em><br><strong>渲染进程（Renderer Process）中的主线程（Main Thread）</strong></p><p><em>单线程js属于浏览器的哪个进程？</em><br>单线程的js → 主线程（Main Thread）→ <strong>渲染进程（Renderer Process）</strong></p><p><em>js为什么要设计成单线程的？</em><br>其实更为严谨的表述是：“浏览器中的js执行和UI渲染是在一个线程中顺序发生的。”<br>这是因为在渲染进程的主线程在解析HTML生成DOM树的过程中，如果此时执行JS，主线程会主动暂停解析HTML，先去执行JS，等JS解析完成后，再继续解析HTML。</p><p><em>那么为什么要“主线程会主动暂停解析HTML，先去执行JS，再继续解析HTML呢”？</em></p><p><strong>这是主线程在解析HTML生成DOM树的过程中会执行<code>style</code>，<code>layout</code>，<code>render</code>以及<code>composite</code>的操作，而JS可以操作DOM，CSSOM，会影响到主线程在解析HTML的最终渲染结果，最终页面的渲染结果将变得不可预见。</strong></p><p>如果主线程一边解析HTML进行渲染，JS同时在操作DOM或者CSSOM，结果会分为以下情况：</p><ul><li>以主线程解析HTML的渲染结果为准</li><li>以JS同时在操作DOM或者CSSOM的渲染结果为准</li></ul><p>考虑到最终页面的渲染效果的一致性，所以js在浏览器中的实现，被设计成为了JS执行阻塞UI渲染型。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环可以拆为“事件”+“循环”。</p><p>先来聊聊“事件”：</p><ul><li>click、mouseover等等交互事件</li><li>事件冒泡、事件捕获、事件委托等等</li><li>addEventListener、removeEventListener()</li><li>CustomEvent（自定义事件实现自定义交互）</li><li>EventEmitter、EventBus（on，emit，once，off）</li><li>第三方库的事件系统</li></ul><p>有事件，就有<strong>事件处理器</strong>：在事件处理器中，我们会应对这个事件做一些特殊操作。</p><p>如果我们的主线程只是静态的，没有循环的话，可以用js伪代码将其表述为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hello World！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hello JavaScript！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行完一次mainThread()之后，这段代码就无效了，mainThread并不是一种激活状态，对于I/O事件是没有办法捕获到的。</p><p>因此对事件加入了“循环”，将渲染进程的主线程变为激活状态，可以用js伪代码表述如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// click event</span><span class="token keyword">function</span> <span class="token function">clickTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"我点击按钮了"</span><span class="token punctuation">}</span><span class="token comment">// 可以是while循环</span><span class="token keyword">function</span> <span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">clickTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>“通知click事件监听器”<span class="token punctuation">)</span> <span class="token punctuation">}</span>        clickTrigger <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以是for循环：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">clickTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>“通知click事件监听器”<span class="token punctuation">)</span> <span class="token punctuation">}</span>    clickTrigger <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在事件监听器中做出响应：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"多亏了事件循环，我（浏览器）才能知道用户做了什么操作"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列可以拆为“消息”+“队列”。 消息可以理解为用户I/O；队列就是先进先出的数据结构。 而消息队列，则是用于连接用户I/O与事件循环的桥梁。</p><p><strong>队列数据结构图</strong></p><p><img src="https://s2.loli.net/2022/08/06/mUBnAaTzV17hQb5.png" alt="队列数据结构图"></p><p><strong>入队出队图</strong></p><p><img src="https://s2.loli.net/2022/08/06/orNHakKW6p7RFi5.png" alt="入队出队图"></p><p><em>在js中，如何发现出队列FIFO的特性？</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 定义一个队列</span><span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 入队</span>queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// queue[1,2,3,4]</span><span class="token comment">// 出队</span>queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 queue [2,3,4]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设用户做出了”click button1”,”click button3”,”click button 2”的操作。 事件队列定义为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> taskQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"click button1"</span><span class="token punctuation">,</span><span class="token string">"click button3"</span><span class="token punctuation">,</span><span class="token string">"click button 2"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">.</span>length<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    taskQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 任务依次出队</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>任务依次出队： <code>click button1</code> <code>click button3</code> <code>click button 2</code></p><p>此时由于mainThread有事件循环，它会被浏览器渲染进程的主线程事件循环系统捕获，并在对应的事件处理器做出响应。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">button1<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click button1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>button2<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click button 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>button3<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click button3"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依次打印：”click button1”，”click button3”，”click button 2”。</p><p>因此，<strong>可以将消息队列理解为连接用户I/O操作和浏览器事件循环系统的任务队列。</strong></p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p><strong>宏任务</strong></p><p>(macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p><p><strong>微任务</strong></p><p>microtask,可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。</p><h3 id="哪些属于宏任务？"><a href="#哪些属于宏任务？" class="headerlink" title="哪些属于宏任务？"></a>哪些属于宏任务？</h3><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>requestAnimationFrame</li><li>I/O</li><li>UI渲染</li></ul><h3 id="哪些属于微任务？"><a href="#哪些属于微任务？" class="headerlink" title="哪些属于微任务？"></a>哪些属于微任务？</h3><ul><li>Promise</li><li>MutationObserver</li><li>process.nextTick</li><li>queueMicrotask</li></ul><h2 id="事件循环，消息队列与宏任务、微任务之间的关系"><a href="#事件循环，消息队列与宏任务、微任务之间的关系" class="headerlink" title="事件循环，消息队列与宏任务、微任务之间的关系"></a>事件循环，消息队列与宏任务、微任务之间的关系</h2><ul><li>宏任务入队消息队列，可以将消息队列理解为宏任务队列</li><li>每个宏任务内有一个微任务队列，执行过程中微任务入队当前宏任务的微任务队列</li><li>宏任务微任务队列为空时才会执行下一个宏任务</li><li>事件循环捕获队列出队的宏任务和微任务并执行</li></ul><p>事件循环会不断地处理消息队列出队的任务，而宏任务指的就是入队到消息队列中的任务，每个宏任务都有一个微任务队列，宏任务在执行过程中，如果此时产生微任务，那么会将产生的微任务入队到当前的微任务队列中，在当前宏任务的主要任务完成后，会依次出队并执行微任务队列中的任务，直到当前微任务队列为空才会进行下一个宏任务。</p><p><strong>浏览器页面循环系统原理图</strong></p><p><i>消息队列和事件循环</i></p><p>线程的一次执行</p><p><img src="https://s2.loli.net/2022/08/06/MoLs4SiYWHwUxZn.png"></p><p>在线程中引入事件循环</p><p><img src="https://s2.loli.net/2022/08/06/8dKcb7FCwZuaeSW.png"></p><p>渲染进程线程之间发送任务</p><p><img src="https://pic3.zhimg.com/80/v2-8d1b124eb3f15d00599bc377b72d5aba_720w.jpg"><br><img src="https://pic4.zhimg.com/80/v2-1c8a495a5cb1f6b22cd3c742da90aafb_720w.jpg"></p><p>线程模型：队列 + 循环</p><p><img src="https://pic3.zhimg.com/80/v2-7802282fcaaaf814c95b2bafb656e982_720w.jpg"></p><p>跨进程发送消息</p><p><img src="https://pic1.zhimg.com/80/v2-9549cf89a6557150edf1b9ed6ed27274_720w.jpg"></p><p>单个任务执行时间过久</p><p><img src="https://pic4.zhimg.com/80/v2-4874dbf5343d2612b4785366a99c4ffb_720w.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器内多个标签页之间的通信</title>
      <link href="/2022/08/05/liu-lan-qi-nei-duo-ge-biao-qian-ye-zhi-jian-de-tong-xin/"/>
      <url>/2022/08/05/liu-lan-qi-nei-duo-ge-biao-qian-ye-zhi-jian-de-tong-xin/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用 <code>WebSocket</code>，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。<br> <code>WebSocket</code>特点：</p><ul><li>保持连接状态，HTTP协议是无状态连接，即请求完毕后就会关闭连接；</li><li>全双工通信，客户端和服务端平等对待，可以互相通信；</li><li>建立在TCP协议之上；</li><li>没有同源共享策略，即可实现跨域共享。</li></ul></li><li><p>使用 <code>SharedWorker</code> （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。</p></li><li><p>可以调用 <code>localStorage</code>、<code>cookies</code> 等本地存储方式，<code>localStorge</code> 另一个浏览上下文里被添加、修改或删除时，它都会触发一个 <code>storage</code> 事件，我们通过监听 <code>storage</code> 事件，控制它的值来进行页面信息通信。<br><code>localStorage</code>特点：</p><ul><li>同域共享存储空间；</li><li>持久化将数据存储在浏览器；</li><li>提供事件监听<code>localStorage</code>变化。</li></ul></li><li><p>如果我们能够获得对应标签页的引用，通过 <code>postMessage</code> 方法也是可以实现多个标签页通信的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Label 标签的作用</title>
      <link href="/2022/08/05/label-biao-qian-de-zuo-yong/"/>
      <url>/2022/08/05/label-biao-qian-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<p><code>label</code> 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Number:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“text“</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iframe 的缺点</title>
      <link href="/2022/08/05/iframe-de-que-dian/"/>
      <url>/2022/08/05/iframe-de-que-dian/</url>
      
        <content type="html"><![CDATA[<p><code>iframe</code> 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><h2 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h2><ol><li><code>iframe</code> 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 <code>iframe</code> 的 <code>src</code> 可以避免这种阻塞情况。</li><li>搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。</li><li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li><li>浏览器的后退按钮失效。</li><li>小型的移动设备无法完全显示框架。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookies，sessionStorage 和 localStorage 的区别</title>
      <link href="/2022/08/05/cookies-sessionstorage-he-localstorage-de-qu-bie/"/>
      <url>/2022/08/05/cookies-sessionstorage-he-localstorage-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><code>SessionStorage</code>， <code>LocalStorage</code>， <code>Cookie</code> 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别在于前两者属于 HTML5 WebStorage，创建它们的目的是便于客户端存储数据。而 <code>cookie</code> 是网站为了标示用户身份而储存用户本地终端上的数据（通常经过加密）。<code>cookie</code> 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不要），会在浏览器和服务器间来回传递。</p><table><thead><tr><th></th><th>区别</th></tr></thead><tbody><tr><td>存储大小</td><td><code>cookie</code> 数据大小不能超过 4k。<br><code>sessionStorage</code> 和 <code>localStorage</code> 虽然也有存储大小的限制，但比 <code>cookie</code> 大得多，可以达到 5M 或更大。</td></tr><tr><td>有效时间</td><td><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。<br> <code>sessionStorage</code> 数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。<br><code>cookie</code> 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</td></tr><tr><td>作用域</td><td><code>sessionStorage</code>  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。<br><code>localStorage</code> 在所有同源窗口中都是共享的。<br><code>cookie</code> 在所有同源窗口中都是共享的。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 语义化</title>
      <link href="/2022/08/05/html-yu-yi-hua/"/>
      <url>/2022/08/05/html-yu-yi-hua/</url>
      
        <content type="html"><![CDATA[<ol><li>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；</li><li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的；</li><li>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO（搜索引擎优化）；</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5的新特性</title>
      <link href="/2022/08/05/html5-de-xin-te-xing/"/>
      <url>/2022/08/05/html5-de-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><ul><li>画布： <code>canvas</code>;</li><li>音视频： <code>video</code> 和 <code>audio</code> 元素;</li><li>web存储：本地离线存储 <code>localStorage</code> 长期存储数据，浏览器关闭后数据不丢失；<code>sessionStorage</code> 的数据在浏览器关闭后自动删除;</li><li>语义化更好的内容元素，比如 <code>article</code>、<code>footer</code>、<code>header</code>、<code>main</code>、<code>nav</code>、<code>section</code>;</li><li>表单控件，<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code>;</li><li>新的技术 <code>webworker</code>， <code>websocket</code>；</li><li>新的文档属性 <code>document.visibilityState</code>。</li></ul><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><ul><li>纯表现的元素：<code>basefont</code>，<code>big</code>，<code>center</code>，<code>font</code>, <code>s</code>，<code>strike</code>，<code>tt</code>，<code>u</code>;</li><li>对可用性产生负面影响的元素：<code>frame</code>，<code>frameset</code>，<code>noframes</code>；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重绘和重排（回流）</title>
      <link href="/2022/08/05/chong-hui-he-chong-pai-hui-liu/"/>
      <url>/2022/08/05/chong-hui-he-chong-pai-hui-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 <code>background-color</code>，这样的操作称为<mark>重绘</mark>。</p><h2 id="重排（回流）"><a href="#重排（回流）" class="headerlink" title="重排（回流）"></a>重排（回流）</h2><p>当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作称为<mark>回流</mark>。</p><br><ins>一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</ins><h3 id="常见引起回流属性和方法"><a href="#常见引起回流属性和方法" class="headerlink" title="常见引起回流属性和方法"></a>常见引起回流属性和方法</h3><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p><ol><li>添加或者删除可见的 DOM 元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度；</li><li>内容变化，比如用户在 input 框中输入文字；</li><li>浏览器窗口尺寸改变——resize事件发生时；</li><li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性；</li><li>设置 <code>style</code> 属性的值；</li><li>修改网页的默认字体时。</li></ol><p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong>回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><p><em>常见引起重绘属性和方法：</em><br><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-14.png" alt="常见引起回流属性和方法"></p><p><em>常见引起回流属性和方法：</em><br><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-13.png" alt="常见引起重绘属性和方法"></p><h3 id="如何减少回流？"><a href="#如何减少回流？" class="headerlink" title="如何减少回流？"></a>如何减少回流？</h3><ol><li>使用 <code>transform</code> 替代 <code>top</code>；</li><li>不要把节点的属性值放在一个循环里当成循环里的变量；</li><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局；</li><li>把 DOM 离线后修改。如：使用 <code>documentFragment</code> 对象在内存里操作 DOM；</li><li>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 <code>class</code>，然后修改 DOM 的 <code>className</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器解析过程</title>
      <link href="/2022/08/04/liu-lan-qi-jie-xi-guo-cheng/"/>
      <url>/2022/08/04/liu-lan-qi-jie-xi-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>在浏览器渲染过程当中，遇到<code>JavaScript</code> 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 <code>JavaScript</code>，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p><p>也就是说，如果我们想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为我们可以给 script 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</p><br><p>js脚本没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>defer</td><td>表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</td></tr><tr><td>async</td><td>表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</td></tr></tbody></table><p><img src="/../images/defer%E3%80%81async%E5%8C%BA%E5%88%AB.png" alt="defer、async区别"></p><p><strong>文档的预解析:</strong><br> Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p><p><strong>CSS 如何阻塞文档解析？</strong><br>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 <code>CSSOM</code> 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 <code>CSSOM</code>，然后再执行 JavaScript，最后再继续文档的解析。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的渲染原理</title>
      <link href="/2022/08/04/liu-lan-qi-de-xuan-ran-yuan-li/"/>
      <url>/2022/08/04/liu-lan-qi-de-xuan-ran-yuan-li/</url>
      
        <content type="html"><![CDATA[<ol><li>首先解析收到的文档，根据文档定义构建一棵 <code>DOM 树</code>，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成 <code>CSSOM 规则树</code>。</li><li>根据 <code>DOM 树</code>和 <code>CSSOM 规则树</code>构建渲染树。渲染树的节点被称为<mark>渲染对象</mark>，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做<mark>回流</mark>）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动<mark>重排</mark>”。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ol><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器内核的理解</title>
      <link href="/2022/08/04/liu-lan-qi-nei-he-de-li-jie/"/>
      <url>/2022/08/04/liu-lan-qi-nei-he-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p>主要分成两部分：<code>渲染引擎</code>和<code>JS引擎</code>。<br><code>渲染引擎</code>的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。<br><code>JS引擎</code>：解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。<br><br><br><strong>常见的浏览器内核比较</strong></p><table><thead><tr><th>浏览器内核名称</th><th>简介</th></tr></thead><tbody><tr><td>Gecko</td><td>这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</td></tr><tr><td>Presto</td><td>Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</td></tr><tr><td>Webkit</td><td>Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</td></tr><tr><td>Blink</td><td>谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行内元素与块级元素</title>
      <link href="/2022/08/03/xing-nei-yuan-su-yu-kuai-ji-yuan-su/"/>
      <url>/2022/08/03/xing-nei-yuan-su-yu-kuai-ji-yuan-su/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th></th><th>定义</th><th>常用元素</th></tr></thead><tbody><tr><td>行内元素</td><td>一个行内元素只占据它对应标签的边框所包含的空间。<ins>（没有宽高）</ins></td><td><code>a</code> <code>b</code> <code>span</code> <code>img</code> <code>strong</code> <code>sub</code> <code>sup</code> <code>button</code> <code>input</code> <code>label</code> <code>select</code> <code>textarea</code></td></tr><tr><td>块级元素</td><td>块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。</td><td><code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code> <code>h3</code> <code>h4</code> <code>h5</code> <code>h6</code> <code>p</code></td></tr></tbody></table><br><strong>两者区别：</strong><br>1. <mark>格式上</mark>，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。<br>2. <mark>内容上</mark>，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。<br>3. 行内元素与块级元素属性的不同，主要是盒模型属性上：<mark>行内元素</mark>不支持设置宽高；<mark>行内元素</mark>支持水平方向的padding、border、margin；行内元素可以设置垂直方向的padding、border、margin，但是不会影响布局。<br><br><strong>行内块元素：</strong><p>通过<code>display:inline-block</code>设置，既有行内元素的特点也有块级元素的特点：<br>1.可以改变宽高（块级元素特点）<br>2.不独立成行（行内元素特点）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SGML 、 HTML 、XML 和 XHTML 的区别</title>
      <link href="/2022/08/03/sgml-html-xml-he-xhtml-de-qu-bie/"/>
      <url>/2022/08/03/sgml-html-xml-he-xhtml-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><mark>SGML</mark> 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。<br><br><br><mark>HTML</mark> 是超文本标记语言，主要是用于规定怎么显示网页。<br><br><br><mark>XML</mark> 是可扩展标记语言，是未来网页语言的发展方向。<br><br><br><ins><mark>XML</mark> 和 <mark>HTML</mark> 的最大区别就在于 <mark>XML</mark> 的标签是可以自己创建的，数量无限多,而 <mark>HTML</mark> 的标签都是固定的而且数量有限。</ins><br><br><br><mark>XHTML</mark> 也是现在基本上所有网页都在用的标记语言，他其实和 <mark>HTML</mark> 没什么本质的区别，标签都一样，用法也都一样，就是比 <mark>HTML</mark> 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Front-matter选项作用</title>
      <link href="/2022/08/03/front-matter-xuan-xiang-zuo-yong/"/>
      <url>/2022/08/03/front-matter-xuan-xiang-zuo-yong/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><mark>Markdown</mark> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根据 <mark>_config.yml</mark> 中的 author</td><td>文章作者</td></tr><tr><td>img</td><td><mark>eatureImages</mark> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <mark><a href="http://xxx.com/xxx.jpg">http://xxx.com/xxx.jpg</a></mark></td></tr><tr><td>top</td><td><mark>true</mark></td><td>推荐文章（文章是否置顶），如果 top 值为 <mark>true</mark>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><mark>false</mark></td><td>隐藏文章，如果hide值为true，则文章不会在首页显示</td></tr><tr><td>cover</td><td><mark>false</mark></td><td><mark>v1.0.2</mark>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><mark>v1.0.2</mark>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <mark>password</mark> 的值，该值必须是用 <mark>SHA256</mark> 加密后的密码，防止被他人识破。前提是在主题的 <mark>config.yml</mark> 中激活了 <mark>verifyPassword</mark> 选项</td></tr><tr><td>toc</td><td>true</td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <mark>config.yml</mark> 中激活了 toc 选项</td></tr><tr><td>mathjax</td><td><mark>false</mark></td><td>是否开启数学公式支持 ，本文章是否开启 <mark>mathjax</mark>，且需要在主题的 <mark>_config.yml</mark> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><br><p><a href="https://blog.17lai.site/posts/cf0f47fd">Hexo Markdown以及各种插件功能测试</a></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOCTYPE的作用</title>
      <link href="/2022/08/02/doctype-de-zuo-yong/"/>
      <url>/2022/08/02/doctype-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<p><big>相关知识点:</big><br>IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的<br><mark>&lt;!DOCTYPE&gt;</mark>声明位于HTML文档中的第一行，处于<mark>html</mark>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<br>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</p><p><mark>&lt;!DOCTYPE&gt;</mark>声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。<br>在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。<br>在<mark>html5</mark>之后不再需要指定 DTD 文档，因为<mark>html5</mark>以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而<mark>html5</mark>不再基于 SGML 了，所以不再需要使用 DTD。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
