<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue生命周期</title>
      <link href="/2022/08/30/vue-sheng-ming-zhou-qi/"/>
      <url>/2022/08/30/vue-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">创建前、后beforeCreate   <span class="token operator">===</span><span class="token operator">&gt;</span>   没有data，没有domcreated        <span class="token operator">===</span><span class="token operator">&gt;</span>   有data，没有dom挂载前、后beforeMount    <span class="token operator">===</span><span class="token operator">&gt;</span>   有data，没有dom（其实已经在准备了）mounted        <span class="token operator">===</span><span class="token operator">&gt;</span>   有data，有dom修改前、后beforeUpdateupdated销毁前、后beforeDestroydestroyed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="什么时候用哪些生命周期？"><a href="#什么时候用哪些生命周期？" class="headerlink" title="什么时候用哪些生命周期？"></a>什么时候用哪些生命周期？</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">created    <span class="token operator">===</span><span class="token operator">&gt;</span>   请求接口mounted    <span class="token operator">===</span><span class="token operator">&gt;</span>   dom操作的时候updated    <span class="token operator">===</span><span class="token operator">&gt;</span>   观测数据是否更新了destroyed  <span class="token operator">===</span><span class="token operator">&gt;</span>   当用户关闭页面，但是业务上要记录一些东西的时候<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="bvideo">    <a href="//www.bilibili.com/video/BV1oa411977E" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/94aac44deb4ab4f06bca3b8b585f00691ce8c1cb.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">02:06:19</span>            </div>            <div class="bvideo-info">                <p class="title">vue生命周期、axios二次封装、api解耦、环境变量、$nextTick原理【最新录制vue课程片段】</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>5712</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>8</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">老张前端</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-if(条件渲染)、v-for(列表渲染)、key的工作原理</title>
      <link href="/2022/08/28/v-if-tiao-jian-xuan-ran-v-for-lie-biao-xuan-ran-key-de-gong-zuo-yuan-li/"/>
      <url>/2022/08/28/v-if-tiao-jian-xuan-ran-v-for-lie-biao-xuan-ran-key-de-gong-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p><strong>写法：</strong></p><ol><li>v-if=“表达式”</li><li>v-else-if=“表达式”</li><li>v-else=“表达式”</li></ol><p>适用于：<strong>切换频率较低的场景</strong></p><p>特点：不展示的DOM元素直接被移除</p><p>注意：v-if可以和：v-else-if、v-else一起使用，但要求结构不能被打断</p><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p><strong>写法：</strong></p><p>v-show=“表达式”</p><p>适用于：<strong>切换频率较高的场景</strong></p><p>特点：没有展示的DOM元素没有被移除，仅仅是使用样式隐藏掉。</p><p><strong>备注：使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取</strong></p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令"></a>v-for指令</h3><ol><li>用于展示列表数据</li><li>语法：v-for=”(item,idex) in xxx” :key=”yyy”</li><li>可遍历：数组、对象、字符串（用得少）、指定次数（用的很少）</li></ol><p><img src="https://s2.loli.net/2022/08/28/Zr2XElaD1wgAbec.png"><br><img src="https://s2.loli.net/2022/08/28/vpgea2uMh1bZHI4.png" alt="列表渲染例子"></p><h2 id="key的工作原理"><a href="#key的工作原理" class="headerlink" title="key的工作原理"></a>key的工作原理</h2><h3 id="虚拟DOM中key的作用"><a href="#虚拟DOM中key的作用" class="headerlink" title="虚拟DOM中key的作用"></a>虚拟DOM中key的作用</h3><p>key是虚拟DOM对象的标识，当数据发生变化的时候，vue会根据【新数据】生成【新的虚拟DOM】</p><p>随后vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p><h3 id="对比规则："><a href="#对比规则：" class="headerlink" title="对比规则："></a>对比规则：</h3><ol><li>旧虚拟DOm中找到了与新虚拟DOM相同的key：</li></ol><ul><li>若虚拟DOM中内容没有变，直接使用之前的真是DOM</li><li>若虚拟DOM中内容变了，则生成新的真是DOM，随后替换页面之前的真是DOM</li></ul><ol start="2"><li>旧虚拟DOM中未找到与新虚拟DOM相同的key</li></ol><ul><li>创建新的真实DOM，随后渲染到页面</li></ul><h3 id="如果没有key会怎样"><a href="#如果没有key会怎样" class="headerlink" title="如果没有key会怎样"></a>如果没有key会怎样</h3><p>如果不使用key，vue会使用一种最大限度减少动态元素并且尽可能尝试就地<strong>修改/复用</strong>相同类型元素的算法；而使用key时，它会<strong>基于key的变化重新排列元素顺序</strong>，并且会<strong>移除/销毁</strong>key不存在的元素。<br><a href="https://blog.csdn.net/coderheart/article/details/125122137">v-for的key的作用</a></p><h3 id="用index作为key可能会引发的问题"><a href="#用index作为key可能会引发的问题" class="headerlink" title="用index作为key可能会引发的问题"></a>用index作为key可能会引发的问题</h3><ol><li>若对数据进行：逆序添加、删除等破坏顺序的操作：</li></ol><ul><li>会产生没有必要的真实Dom更新==&gt; 界面效果没有问题，但是效率低</li></ul><ol start="2"><li>如果结构中还包含输入类的DOM：</li></ol><ul><li>会产生错误的DOM更新==&gt; 界面有问题<br><a href="https://blog.csdn.net/z591102/article/details/106682298/">为什么不建议使用 index 作为 key 值</a></li></ul><h3 id="开发中如何选择key"><a href="#开发中如何选择key" class="headerlink" title="开发中如何选择key"></a>开发中如何选择key</h3><ol><li>最好使用每条数据唯一的标识作为key，比如id、手机号、身份证号、学号等唯一值。</li><li>如果不存在对数据进行逆序添加、删除等破坏顺序的操作，仅用于渲染到列表进行展示，使用index作为key是没有任何问题的。</li></ol><p>这部分内容有些抽象 总之一句话 在使用v-for进行列表渲染时，一定要用:key=”xxx” 做唯一标识，且如果使用index做为唯一标识在有些特殊情况下 会有问题！如果没有添加key值控制台不会报错 但是后面编程中会遇到各种各样难以理解的问题！</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtual DOM和diff算法</title>
      <link href="/2022/08/23/virtual-dom-he-diff-suan-fa/"/>
      <url>/2022/08/23/virtual-dom-he-diff-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Virtual-DOM？"><a href="#什么是Virtual-DOM？" class="headerlink" title="什么是Virtual DOM？"></a>什么是Virtual DOM？</h2><p>首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</p><p>当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</p><p>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</p><p>我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</p><h2 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h2><p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</p><p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p><p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 类数组对象</title>
      <link href="/2022/08/19/javascript-lei-shu-zu-dui-xiang/"/>
      <url>/2022/08/19/javascript-lei-shu-zu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<p>一个拥有 <code>length</code> 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。</p><p>常见的类数组对象有 <code>arguments</code> 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 <code>length</code> 属性值，代表可接收的参数个数。</p><h2 id="常见的类数组转换为数组的方法有这样几种"><a href="#常见的类数组转换为数组的方法有这样几种" class="headerlink" title="常见的类数组转换为数组的方法有这样几种"></a>常见的类数组转换为数组的方法有这样几种</h2><h3 id="1-通过-call-调用数组的-slice-方法来实现转换"><a href="#1-通过-call-调用数组的-slice-方法来实现转换" class="headerlink" title="1. 通过 call 调用数组的 slice 方法来实现转换"></a>1. 通过 call 调用数组的 slice 方法来实现转换</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-通过-call-调用数组的-splice-方法来实现转换"><a href="#2-通过-call-调用数组的-splice-方法来实现转换" class="headerlink" title="2. 通过 call 调用数组的 splice 方法来实现转换"></a>2. 通过 call 调用数组的 splice 方法来实现转换</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-通过-apply-调用数组的-concat-方法来实现转换"><a href="#3-通过-apply-调用数组的-concat-方法来实现转换" class="headerlink" title="3. 通过 apply 调用数组的 concat 方法来实现转换"></a>3. 通过 apply 调用数组的 concat 方法来实现转换</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-通过-Array-from-方法来实现转换"><a href="#4-通过-Array-from-方法来实现转换" class="headerlink" title="4. 通过 Array.from 方法来实现转换"></a>4. 通过 Array.from 方法来实现转换</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM 操作——添加、移除、移动、复制、创建和查找节点</title>
      <link href="/2022/08/19/dom-cao-zuo-tian-jia-yi-chu-yi-dong-fu-zhi-chuang-jian-he-cha-zhao-jie-dian/"/>
      <url>/2022/08/19/dom-cao-zuo-tian-jia-yi-chu-yi-dong-fu-zhi-chuang-jian-he-cha-zhao-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="创建新节点"><a href="#创建新节点" class="headerlink" title="创建新节点"></a>创建新节点</h2><p>以下方法都是document调用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">createElement</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="添加、移除、替换、插入"><a href="#添加、移除、替换、插入" class="headerlink" title="添加、移除、替换、插入"></a>添加、移除、替换、插入</h2><p>以下方法都是父元素调用，操作子元素：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token function">removeChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token function">replaceChild</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">,</span>old<span class="token punctuation">)</span><span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">,</span>old<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">getAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">hasAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">removeAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的模块化</title>
      <link href="/2022/08/19/js-de-mo-kuai-hua/"/>
      <url>/2022/08/19/js-de-mo-kuai-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="模块化开发怎么做？"><a href="#模块化开发怎么做？" class="headerlink" title="模块化开发怎么做？"></a>模块化开发怎么做？</h2><ol><li><p><mark>全局function模式</mark>：由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</p></li><li><p><mark>namespace模式</mark>：后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的模块成员，外部代码可以修改内部属性的值。</p></li><li><p><mark>IIFE模式（闭包）</mark>：之后发展为立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。但是这种方法无法解决当前这个模块依赖另一个模块的问题。</p></li><li><p><mark>IIFE增强模式</mark>：通过在IIFE模式中引入依赖，这就是现代模块实现的基石。</p></li></ol><h2 id="js-的几种模块规范？"><a href="#js-的几种模块规范？" class="headerlink" title="js 的几种模块规范？"></a>js 的几种模块规范？</h2><p>js 中现在比较成熟的有四种模块加载方案。</p><p>第一种是 <strong>CommonJS</strong> 方案，它通过 require 来引入模块，通过 <code>module.exports</code> 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</p><p>第二种是 <strong>AMD</strong> 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p><p>第三种是 <strong>CMD</strong> 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</p><h3 id="AMD-和-CMD-规范的区别？"><a href="#AMD-和-CMD-规范的区别？" class="headerlink" title="AMD 和 CMD 规范的区别？"></a>AMD 和 CMD 规范的区别？</h3><p>它们之间的主要区别有两个方面。</p><ol><li><p>第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</p></li><li><p>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// AMD 默认推荐</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./a"</span><span class="token punctuation">,</span> <span class="token string">"./b"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 依赖必须一开始就写好</span>  a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 此处略去 100 行</span>  b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// CMD</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 此处略去 100 行</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖可以就近书写</span>  b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。</p><h2 id="ES6-模块与-CommonJS-模块、AMD、CMD-的差异"><a href="#ES6-模块与-CommonJS-模块、AMD、CMD-的差异" class="headerlink" title="ES6 模块与 CommonJS 模块、AMD、CMD 的差异"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异</h2><ol><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li></ol><h3 id="requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决跨域问题</title>
      <link href="/2022/08/19/ru-he-jie-jue-kua-yu-wen-ti/"/>
      <url>/2022/08/19/ru-he-jie-jue-kua-yu-wen-ti/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 通过 jsonp 跨域<br>2. document.domain + <code>iframe</code> 跨域<br>3. location.hash + <code>iframe</code><br>4. <code>window.name</code> + <code>iframe</code> 跨域<br>5. <code>postMessage</code> 跨域<br>6. 跨域资源共享（<code>CORS</code>)<br>7. nginx 代理跨域<br>8. nodejs 中间件代理跨域<br>9. WebSocket 协议跨域</strong></p><p>解决跨域的方法我们可以根据我们想要实现的目的来划分。</p><p>首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 <code>document.domain</code> 来解决。</p><p>（1）将 <code>document.domain</code> 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 <code>iframe</code> 的话，我们也可以对这个 <code>iframe</code> 进行操作。</p><p>如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 <code>iframe</code> 进行通信的问题，我们可以使用 <code>location.hash</code> 或者 <code>window.name</code> 或者 <code>postMessage</code> 来解决。</p><p>（2）使用 <code>location.hash</code> 的方法，我们可以在主页面动态的修改 <code>iframe</code> 窗口的 hash 值，然后在 <code>iframe</code> 窗口里实现监听函数来实现这样一个单向的通信。因为在 <code>iframe</code> 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 <code>iframe</code> 中再加入一个 <code>iframe</code> ，这个 <code>iframe</code> 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</p><p>（3）使用 <code>window.name</code> 的方法，主要是基于同一个窗口中设置了 <code>window.name</code> 后不同源的页面也可以访问，所以不同源的子页面可以首先在 <code>window.name</code> 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 <code>window.name</code> 中的数据了，这种方式的好处是可以传输的数据量大。</p><p>（4）使用 <code>postMessage</code> 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 <code>postMessage</code> 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。</p><p>如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、<code>CORS</code>、websocket 协议、服务器代理来解决问题。</p><p>（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。</p><p>（6）使用 <code>CORS</code> 的方式，<code>CORS</code> 是一个 W3C 标准，全称是”跨域资源共享”。<code>CORS</code> 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 <code>CORS</code> 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 <code>CORS</code> 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 <strong>Access-Control-Allow-Origin</strong> 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 <strong>Access-Control-</strong> 开头的字段。</p><p>非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</p><p>（7）使用 websocket 协议，这个协议没有同源限制。</p><p>（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果返回。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的缓存机制</title>
      <link href="/2022/08/18/liu-lan-qi-de-huan-cun-ji-zhi/"/>
      <url>/2022/08/18/liu-lan-qi-de-huan-cun-ji-zhi/</url>
      
        <content type="html"><![CDATA[<p>浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。</p><p>web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。</p><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 <code>Expires</code> 属性和 <code>Cache-Control</code> 属性。</p><p>服务器通过在响应头中添加 <code>Expires</code> 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p><p><code>Expires</code> 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 <code>Cache-Control</code> 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 <code>max-age</code> 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 <code>Expires</code>来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 no-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。</p><p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，<code>Cache-Control</code> 的优先级要高于 <code>Expires</code> 。</p><p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。<br>如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 <code>Etag</code> 和 <code>Last-Modified</code> 属性。</p><p>服务器通过在响应头中添加 <code>Last-Modified</code> 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 <code>If-Modified-Since</code> 的属性，属性值为上一次资源返回时的 <code>Last-Modified</code> 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 <code>Last-Modified</code> 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已经改变了但是 <code>Last-Modified</code> 却没有改变，这样会造成缓存命中的不准确。</p><p>因为 <code>Last-Modified</code> 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 <code>Etag</code> 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 <code>Etag</code> 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 <code>Last-Modified</code> 的方式更加精确。</p><p>当 <code>Last-Modified</code> 和 Etag 属性同时出现的时候，<code>Etag</code> 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 <code>Last-Modified</code> 应该保持一致，因为每个服务器上 <code>Etag</code> 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p><p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则服务器返回最新的资源给浏览器。</p><div class="bvideo">    <a href="//www.bilibili.com/video/BV17Q4y127We" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/f10b9274b55f9e0bc901a28ce553f290c4d0d4d2.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:23:09</span>            </div>            <div class="bvideo-info">                <p class="title">HTTP 缓存【JS面试题小合集】</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>1.0万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>22</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">前端猎人-小野森森-2</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创建一个 Ajax</title>
      <link href="/2022/08/18/ru-he-chuang-jian-yi-ge-ajax/"/>
      <url>/2022/08/18/ru-he-chuang-jian-yi-ge-ajax/</url>
      
        <content type="html"><![CDATA[<p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><h2 id="具体来说，AJAX-包括以下几个步骤："><a href="#具体来说，AJAX-包括以下几个步骤：" class="headerlink" title="具体来说，AJAX 包括以下几个步骤："></a>具体来说，AJAX 包括以下几个步骤：</h2><ol><li>创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li><li>创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li><li>设置响应 HTTP 请求状态变化的函数</li><li>发送 HTTP 请求</li><li>获取异步调用返回的数据</li><li>使用 JavaScript 和 DOM 实现局部刷新</li></ol><h2 id="一般实现："><a href="#一般实现：" class="headerlink" title="一般实现："></a>一般实现：</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token constant">SERVER_URL</span> <span class="token operator">=</span> <span class="token string">"/server"</span><span class="token punctuation">;</span><span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建 Http 请求</span>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token constant">SERVER_URL</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置状态监听函数</span>xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">!==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// 当请求成功时</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">handle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 设置请求失败时的监听函数</span>xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 设置请求头信息</span>xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">"json"</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Accept"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 发送 Http 请求</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// promise 封装实现：</span><span class="token keyword">function</span> <span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 创建一个 promise 对象</span>  <span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 新建一个 http 请求</span>    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置状态的监听函数</span>    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">!==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token comment">// 当请求成功或失败时，改变 promise 的状态</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 设置错误监听函数</span>    xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 设置响应的数据类型</span>    xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">"json"</span><span class="token punctuation">;</span>    <span class="token comment">// 设置请求头信息</span>    xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Accept"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送 http 请求</span>    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> promise<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new 操作符做了什么</title>
      <link href="/2022/08/18/new-cao-zuo-fu-zuo-liao-shi-me/"/>
      <url>/2022/08/18/new-cao-zuo-fu-zuo-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<ol><li>首先创建了一个新的空对象；</li><li>设置原型，将对象的原型设置为函数的 prototype 对象；</li><li>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）；</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><p><strong>实现:</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">objectFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> newObject <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    constructor <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 拿到构造函数</span>    result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>     <span class="token comment">// 参数判断</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> constructor <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"type error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span>  newObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将 this 指向新建对象，并执行函数</span>  result <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>newObject<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断返回对象</span>  <span class="token keyword">let</span> flag <span class="token operator">=</span>    result <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断返回结果</span>  <span class="token keyword">return</span> flag <span class="token operator">?</span> result <span class="token operator">:</span> newObject<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 使用方法</span><span class="token comment">// objectFactory(构造函数, 初始化参数);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>instanceof 的作用</title>
      <link href="/2022/08/18/instanceof-de-zuo-yong/"/>
      <url>/2022/08/18/instanceof-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<p><code>instanceof</code> 运算符用于判断构造函数的 <code>prototype</code> 属性是否出现在对象的原型链中的任何位置。</p><p><strong>实现：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 获取对象的原型</span>    prototype <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 获取构造函数的 prototype 对象</span>  <span class="token comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>proto<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>use strict——严格模式</title>
      <link href="/2022/08/18/use-strict-yan-ge-mo-shi/"/>
      <url>/2022/08/18/use-strict-yan-ge-mo-shi/</url>
      
        <content type="html"><![CDATA[<p><code>use strict</code> 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。</p><h3 id="设立”严格模式”的目的，主要有以下几个："><a href="#设立”严格模式”的目的，主要有以下几个：" class="headerlink" title="设立”严格模式”的目的，主要有以下几个："></a>设立”严格模式”的目的，主要有以下几个：</h3><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><h3 id="使用严格模式区别是什么？"><a href="#使用严格模式区别是什么？" class="headerlink" title="使用严格模式区别是什么？"></a>使用严格模式区别是什么？</h3><ul><li>声明定义变量必须用var</li><li>禁止自定义的函数中的this关键字指向全局对象</li><li>创建eval作用域, 更安全</li></ul><div class="bvideo">    <a href="//www.bilibili.com/video/BV1kp4y1e7h8" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/1f6d0ba5996b79b4c4d28ec88fa6e1b3bfa3141b.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:40:18</span>            </div>            <div class="bvideo-info">                <p class="title">【全网首发：完结】JS 中的严格模式【 经典前端面试题 】</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>1137</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>10</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">前端小夏老师</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是闭包</title>
      <link href="/2022/08/18/shi-me-shi-bi-bao/"/>
      <url>/2022/08/18/shi-me-shi-bi-bao/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>学习闭包我们要清楚函数作用域、内存回收机制、作用域继承。</p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>作用域我们可以认为它是一个封闭的盒子，只让它在这个盒子里面进行操作，也可以称这个盒子为独立作用域。在js中，一个函数要执行时就会在内存里面创建一个独立作用域————封闭的盒子。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/98b65280712ac349c9b25e2e9013d21d.webp?x-oss-process=image/format,png"></p><p>比如在函数中第一个变量，只能在函数这个独立作用域中使用（也就是封闭的盒子）。只要跳出这个作用域，就找不到该变量了。</p><p>而且函数执行完毕之后，这个独立作用域或（封闭的盒子）就会删除。有一种情况下这个封闭的盒子是不会删除的，那就是“闭包”，后面会讲到。</p><h3 id="内存回收机制"><a href="#内存回收机制" class="headerlink" title="内存回收机制"></a>内存回收机制</h3><p>内存回收机制就是不在用到的内存空间，系统会自动进行清理出空间提供给其他程序使用。那回收的前提是什么呢？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e5903a32d24cc2cb8d33197d4dff43af.webp?x-oss-process=image/format,png"></p><p>内部函数引用外部的函数的变量，外部函数执行完毕，作用域也不会删除。从而形成了一种不删除的独立作用域。</p><p>某一个变量或者对象被引用，因此在回收的时候不会释放它，因为被引用代表着被使用，回收机制不会对正在引用的变量或对象进行回收的。</p><h3 id="作用继承"><a href="#作用继承" class="headerlink" title="作用继承"></a>作用继承</h3><p>所谓的作用域继承，就像是儿子可以继承父亲的财产一样。比如我这里有一个大的盒子作为一个父级的作用域，然后在这个大的盒子里边放一个小的盒子，作为子作用域。我们规定可以在小盒子中获取到大盒子中的东西，大盒子不能获取小盒子里的东西就称为作用域继承。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c43a442a68c8364bf013d71227e164eb.webp?x-oss-process=image/format,png"></p><p>在 JS 中，道理是一样的，在一个函数里边我们再声明一个函数，内部函数可以访问外部函数作用域的变量，而外部的函数不能获取到内部函数的作用域变量。</p><p>那好，上边的这几个概念理解了之后，什么是闭包对你来说已经不是什么问题。</p><p>什么是闭包，那就是在一个函数里边再定义一个函数。这个内部函数一直保持有对外部函数中作用域的访问(小盒子可以一直访问大盒子但大盒子不能访问小盒子)。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c43a442a68c8364bf013d71227e164eb.webp?x-oss-process=image/format,png"></p><p>函数执行，形成一个独立作用域，保护里边的私有变量不受外界的干扰，除了保护私有变量外，还可以存储一些内容，这样的模式叫做闭包。</p><h2 id="闭包的作用是什么"><a href="#闭包的作用是什么" class="headerlink" title="闭包的作用是什么"></a>闭包的作用是什么</h2><p>闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p><p><strong>作用</strong>是：通过一系方法，将函数内部的变量(局部变量)转化为全局变量。</p><h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> n<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">;</span>    <span class="token function-variable function">nAdd</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>n<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> f2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> result<span class="token operator">=</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//999</span><span class="token function">nAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1000</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1001</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的<strong>局部变量n一直保存在内存中，并没有在f1调用后被自动清除</strong>。</p><p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是”<mark>nAdd=function(){n+=1}</mark>“这一行，首先<strong>在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量</strong>。 其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个操控者，可以在函数外部对函数内部的局部变量进行操作。</p><h2 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h2><ol><li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p></li><li><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p></li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>当点击事件执行的时候，就会在独立作用域查找 i 的值，此时独立作用域没有 i ，就回去全局作用域查找，此时全局作用域的 i 已经被改变。所以说，要创建一个私有作用域的 i 。</p><p>方法一：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2a9dadefa0743238e4b6254f28a1edc5.webp?x-oss-process=image/format,png"></p><p>方法二：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/22303f5d00aa4c600005c3e767bd9c20.webp?x-oss-process=image/format,png"></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的事件机制</title>
      <link href="/2022/08/18/js-de-shi-jian-ji-zhi/"/>
      <url>/2022/08/18/js-de-shi-jian-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="事件是什么？"><a href="#事件是什么？" class="headerlink" title="事件是什么？"></a>事件是什么？</h2><p>事件是用户操作网页时发生的交互动作，比如 <code>click</code>/<code>move</code>， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 <code>event</code> 对象，包含了该事件发生时的所有相关信息（ <code>event</code> 的属性）以及可以对事件进行的操作（ <code>event</code> 的方法）。</p><h2 id="三种事件模型"><a href="#三种事件模型" class="headerlink" title="三种事件模型"></a>三种事件模型</h2><p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</p><p>第一种事件模型是最早的 <strong>DOM0</strong> 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</p><p>第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 <code>document</code>，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 <code>attachEvent</code> 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</p><p>第三种是 <strong>DOM2</strong> 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 <code>document</code> 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 <code>addEventListener</code>，其中第三个参数可以指定事件是否在捕获阶段执行（默认值为<code>false</code>）。</p><h2 id="事件委派是什么？"><a href="#事件委派是什么？" class="headerlink" title="事件委派是什么？"></a>事件委派是什么？</h2><p>事件委派本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委派。</p><p>使用事件委派我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件委派我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM 和 BOM</title>
      <link href="/2022/08/18/dom-he-bom/"/>
      <url>/2022/08/18/dom-he-bom/</url>
      
        <content type="html"><![CDATA[<p><code>DOM</code> 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</p><p><code>虚拟DOM</code>是为了解决浏览器性能问题而被设计出来的。若一次操作DOM中有十次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这十次更新的diff内容保存到本地一个js中，最终将这个js对象一次性attach 到DOM树上，在进行后续操作。避免大量无谓的计算量。所以，用js对象模拟DOM节点的好处是，页面的更新可以先全部反应在js对象（虚拟DOM）上，操作内存中的js对象的速度显然要更快，等更新完成之后，再将最终的js对象映射成真实的DOM，交由浏览器去绘制。</p><p><code>BOM</code> 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的方法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 <code>location</code> 对象、<code>navigator</code> 对象、<code>screen</code> 对象、<code>history</code>对象等子对象，并且 DOM 的最根本的对象 <code>document</code> 对象也是 BOM 的 window 对象的子对象。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>This 对象的理解</title>
      <link href="/2022/08/17/this-dui-xiang-de-li-jie/"/>
      <url>/2022/08/17/this-dui-xiang-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断：</p><ol><li><p>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象；</p></li><li><p>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象；</p></li><li><p>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象；</p></li><li><p>第四种是 <strong><code>apply</code> 、 <code>call</code> 和 <code>bind</code> 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 <code>apply</code> 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。<code>call</code> 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 <code>call()</code> 方法时，传递给函数的参数必须逐个列举出来。<code>bind</code> 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p><p> <strong>call() 、 apply() 和 bind() 的区别？</strong></p><p> <code>call</code>,<code>apply</code>,<code>bind</code>三者都用于改变函数的this对象的指向。<br> <code>bind</code> 是返回对应函数，便于稍后调用；<code>apply</code> 、<code>call</code> 则是立即调用。<br> <code>call</code>和<code>apply</code>的作用一模一样，区别仅在于传入参数的形式的不同。</p><p> <code>apply</code> 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，<code>apply</code> 方法把这个集合中的元素作为参数传递给被调用的函数。</p><p> <code>call</code> 传入的参数数量不固定，跟 <code>apply</code> 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</p> <div class="bvideo">    <a href="//www.bilibili.com/video/BV1XX4y1w7R6" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/5ee9008f615977ff34ee13f8e7172bdf49199dab.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:06:45</span>            </div>            <div class="bvideo-info">                <p class="title">前端面试题：call、apply、bind的基本概念</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>1.9万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>56</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">晓舟报告</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div></li></ol><p>这四种方式，使用构造器调用模式的优先级最高，然后是 <code>apply</code> 、 <code>call</code> 和 <code>bind</code> 调用模式，然后是方法调用模式，然后是函数调用模式。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 的作用域链</title>
      <link href="/2022/08/17/javascript-de-zuo-yong-yu-lian/"/>
      <url>/2022/08/17/javascript-de-zuo-yong-yu-lian/</url>
      
        <content type="html"><![CDATA[<p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p><p>作用域链的创建过程跟执行上下文的建立有关….</p><div class="bvideo">    <a href="//www.bilibili.com/video/BV1K34y1q7Y3" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/c51cd0adf056490fbaba4fbb84465de5a18330c4.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:07:31</span>            </div>            <div class="bvideo-info">                <p class="title">1分钟搞定JS — 作用域链</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>792</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>27</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">技术痞瑞</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 继承的几种实现方式</title>
      <link href="/2022/08/17/javascript-ji-cheng-de-ji-chong-shi-xian-fang-shi/"/>
      <url>/2022/08/17/javascript-ji-cheng-de-ji-chong-shi-xian-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="原型链方式"><a href="#原型链方式" class="headerlink" title="原型链方式"></a>原型链方式</h2><p>第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向父类构造函数传递参数。</p><h2 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h2><p>第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 <code>Object.create()</code> 方法就是原型式继承的实现。缺点与原型链方式相同。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><h3 id="寄生式组合继承的实现"><a href="#寄生式组合继承的实现" class="headerlink" title="寄生式组合继承的实现"></a>寄生式组合继承的实现</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"My name is "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//子类的原型等价于父类的实例，指向父类的原型</span><span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Student<span class="token punctuation">;</span><span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayMyGrade</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"My grade is "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="bvideo">    <a href="//www.bilibili.com/video/BV1YY4y1W7Uj" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/68a194873e3847c10336ca4256e567fa5125e465.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:20:58</span>            </div>            <div class="bvideo-info">                <p class="title">【JavaScript面试题】JS中的几种继承方法</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>5295</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>27</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">码上通天</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 原型，原型链？ 有什么特点？</title>
      <link href="/2022/08/17/javascript-yuan-xing-yuan-xing-lian-you-shi-me-te-dian/"/>
      <url>/2022/08/17/javascript-yuan-xing-yuan-xing-lian-you-shi-me-te-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><ol><li>每个函数都有一个<code>prototype</code>属性，该属性指向的是原型对象(显示原型对象)</li><li>每个实例对象身上都有一个<code>__proto__</code>属性，该属性指向的也是原型对象(隐式原型对象)</li><li>构造函数的显示原型 === 当前构造函数实例对象的隐式原型对象</li><li>原型对象的本质： 普通的Object实例</li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol><li>查找对象的属性的时候现在自身找，如果自身没有沿着<code>__proto__</code>找原型对象</li><li>如果原型对象上还没有，继续沿着<code>__proto__</code>，直到找到Object的原型对象</li><li>如果还没有找到返回<code>undefined</code></li><li>原型链： 沿着<code>__proto__</code>查找属性(方法)的这条链就是原型链</li></ol><div class="bvideo">    <a href="//www.bilibili.com/video/BV1Q64y1v7fW" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/f8531afc9b84f1e3f748e8a8ab7a6095abe60919.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:23:59</span>            </div>            <div class="bvideo-info">                <p class="title">快速掌握 JS 面试题之『原型和原型链』</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>4.4万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>332</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">前端猎人-小野森森-2</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><h2 id="js-获取原型的方法"><a href="#js-获取原型的方法" class="headerlink" title="js 获取原型的方法"></a>js 获取原型的方法</h2><ul><li><strong>p.proto</strong></li><li><strong>p.constructor.proto</strong></li><li><strong>Object.getPrototypeOf(p)</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token constant">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token keyword">var</span> one<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//官方推荐，规范写法</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>one<span class="token punctuation">.</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不报错，不推荐</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>one<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>proto<span class="token punctuation">)</span><span class="token comment">//同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>null 和 undefined</title>
      <link href="/2022/08/17/null-he-undefined/"/>
      <url>/2022/08/17/null-he-undefined/</url>
      
        <content type="html"><![CDATA[<p>首先 <strong>Undefined</strong> 和 <strong>Null</strong> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <code>undefined</code> 和 <code>null</code>。</p><p><code>undefined</code> 代表的含义是未定义，<code>null</code> 代表的含义是空对象。一般变量声明了但还没有赋值的时候会返回 <code>undefined</code>，<code>null</code>主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p><code>undefined</code> 在 js 中不是一个保留字，这意味着我们可以使用 <code>undefined</code> 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 <code>undefined</code> 值的判断。但是我们可以通过一些方法获得安全的 <code>undefined</code> 值，比如说 <code>void 0</code>。</p><h3 id="如何获取安全的-undefined-值？"><a href="#如何获取安全的-undefined-值？" class="headerlink" title="如何获取安全的 undefined 值？"></a>如何获取安全的 undefined 值？</h3><p>因为 <code>undefined</code> 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 <code>undefined</code> 的正常判断。</p><p>表达式 <code>void ___</code> 没有返回值，因此返回结果是 <code>undefined</code>。void 并不改变表达式的结果，只是让表达式不返回值。</p><ul><li>按惯例我们用 <code>void 0</code> 来获得 <code>undefined</code>。</li><li>除了防止被重写外，还可以减少字节。<code>void 0</code> 代替 <code>undefined</code>省3个字节。（老司机常用）</li></ul><p>当我们对两种类型使用 typeof 进行判断的时候，<code>Null</code> 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">undefined</span>    <span class="token comment">// true</span><span class="token keyword">null</span> <span class="token operator">===</span> <span class="token keyword">undefined</span>   <span class="token comment">// false   数据类型不同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>undefined和undeclared</title>
      <link href="/2022/08/17/undefined-he-undeclared/"/>
      <url>/2022/08/17/undefined-he-undeclared/</url>
      
        <content type="html"><![CDATA[<ul><li>已在作用域中声明但还没有赋值的变量，是 <code>undefined</code> 的。相反，还没有在作用域中声明过的变量，是 <code>undeclared</code> 的。</li><li>对于 <code>undeclared</code> 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。</li><li>并且typeof 对 <code>undefined</code> 和 <code>undeclared</code> 变量返回的都是<code>undefined</code>。其实“ undefined” 和“ is not defined ”是两码事。</li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的内置对象</title>
      <link href="/2022/08/17/js-de-nei-zhi-dui-xiang/"/>
      <url>/2022/08/17/js-de-nei-zhi-dui-xiang/</url>
      
        <content type="html"><![CDATA[<p>全局的对象（global objects）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p><strong>标准内置对象的分类</strong></p><p>（1）<strong>值属性</strong>，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</p><p>例如 Infinity、NaN、undefined、null 字面量</p><p>（2）<strong>函数属性</strong>，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</p><p>例如 eval()、parseFloat()、parseInt() 等</p><p>（3）<strong>基本对象</strong>，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</p><p>例如 Object、Function、Boolean、Symbol、Error 等</p><p>（4）<strong>数字和日期对象</strong>，用来表示数字、日期和执行数学计算的对象。</p><p>例如 Number、Math、Date</p><p>（5）<strong>字符串</strong>，用来表示和操作字符串的对象。</p><p>例如 String、RegExp</p><p>（6）<strong>可索引的集合对象</strong>，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p><p>（7）<strong>使用键的集合对象</strong>，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</p><p>例如 Map、Set、WeakMap、WeakSet</p><p>（8）<strong>矢量集合</strong>，SIMD 矢量集合中的数据会被组织为一个数据序列。</p><p>例如 SIMD 等</p><p>（9）<strong>结构化数据</strong>，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</p><p>例如 JSON 等</p><p>（10）<strong>控制抽象对象</strong></p><p>例如 Promise、Generator 等</p><p>（11）<strong>反射</strong></p><p>例如 Reflect、Proxy</p><p>（12）国际化，为了支持多语言处理而加入 <strong>ECMAScript 的对象</strong>。</p><p>例如 Intl、Intl.Collator 等</p><p>（13）<strong>WebAssembly</strong></p><p>（14）其他</p><p>例如 arguments</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的数据类型</title>
      <link href="/2022/08/17/js-de-shu-ju-lei-xing/"/>
      <url>/2022/08/17/js-de-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<p><strong>数据类型分为两种：</strong></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型共有7种。<mark>字符串（String）</mark>、<mark>数字（Number）</mark>、<mark>布尔（Boolean）</mark>、<mark>空（Null）</mark>、<mark>未定义（Undefined）</mark>,还有在 ES6 中新增的 <mark>Symbol</mark> 类型。<br><mark>BigInt</mark> 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>引用数据类型统称<strong>object对象</strong>，主要包括<mark>对象（Object）</mark>、<mark>数组（Array）</mark>、<mark>函数（Function）</mark>、<mark>日期（Date）</mark>、<mark>正则（RegExp）</mark>等等</p><h2 id="数据类型储存原理"><a href="#数据类型储存原理" class="headerlink" title="数据类型储存原理"></a>数据类型储存原理</h2><h3 id="1-栈内存（基本数据类型（值类型））"><a href="#1-栈内存（基本数据类型（值类型））" class="headerlink" title="1. 栈内存（基本数据类型（值类型））"></a>1. 栈内存（基本数据类型（值类型））</h3><p>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><h3 id="2-栈＋堆内存（引用数据类型（复杂数据类型））"><a href="#2-栈＋堆内存（引用数据类型（复杂数据类型））" class="headerlink" title="2. 栈＋堆内存（引用数据类型（复杂数据类型））"></a>2. 栈＋堆内存（引用数据类型（复杂数据类型））</h3><p>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h4 id="什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="什么是堆？什么是栈？它们之间有什么区别和联系？"></a>什么是堆？什么是栈？它们之间有什么区别和联系？</h4><p>堆和栈的概念存在于数据结构中和操作系统内存中。</p><p>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。</p><p>在操作系统中，内存被分为栈区和堆区。</p><p>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><p>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 三栏布局的实现</title>
      <link href="/2022/08/17/css-san-lan-bu-ju-de-shi-xian/"/>
      <url>/2022/08/17/css-san-lan-bu-ju-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</p><p>这里以左边宽度固定为100px，右边宽度固定为200px为例。</p><h3 id="1-利用绝对定位的方式"><a href="#1-利用绝对定位的方式" class="headerlink" title="1. 利用绝对定位的方式"></a>1. 利用绝对定位的方式</h3><p>左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.center</span> <span class="token punctuation">{</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">margin-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-利用flex布局的方式"><a href="#2-利用flex布局的方式" class="headerlink" title="2. 利用flex布局的方式"></a>2. 利用flex布局的方式</h3><p>左右两栏的宽度分别设置为100px和200px，中间一栏增长系数设置为1。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.center</span> <span class="token punctuation">{</span>  <span class="token property">flex-grow</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-利用浮动的方式"><a href="#3-利用浮动的方式" class="headerlink" title="3. 利用浮动的方式"></a>3. 利用浮动的方式</h3><p>左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.center</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">margin-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-圣杯布局"><a href="#4-圣杯布局" class="headerlink" title="4. 圣杯布局"></a>4. 圣杯布局</h3><p>利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.outer</span><span class="token punctuation">{</span>  <span class="token comment">/*  为左右栏腾出空间  */</span>  <span class="token property">padding-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">padding-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token selector">.left</span><span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.center</span><span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> #bfa<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span><span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> orange<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-双飞翼布局"><a href="#5-双飞翼布局" class="headerlink" title="5. 双飞翼布局"></a>5. 双飞翼布局</h3><p>双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.wrapper</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.center</span> <span class="token punctuation">{</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">margin-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="http://cavszhouyou.top/Demo-Display/ThreeColumnLayout/index.html">《三栏布局 demo 展示》</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 两栏布局的实现</title>
      <link href="/2022/08/17/css-liang-lan-bu-ju-de-shi-xian/"/>
      <url>/2022/08/17/css-liang-lan-bu-ju-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。</p><p>以左边宽度固定为200px为例</p><ol><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的<code>margin-left</code>设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ol><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>第二种是利用flex布局，将左边元素宽度设置为200px。将右边的元素的放大比例设置为1。</li></ol><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">flex-grow</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的<code>margin-left</code>的值设置为200px。</li></ol><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ol><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="http://cavszhouyou.top/Demo-Display/TwoColumnLayout/index.html">《两栏布局 demo 展示》</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 实现上下固定中间自适应布局</title>
      <link href="/2022/08/16/css-shi-xian-shang-xia-gu-ding-zhong-jian-zi-gua-ying-bu-ju/"/>
      <url>/2022/08/16/css-shi-xian-shang-xia-gu-ding-zhong-jian-zi-gua-ying-bu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="利用绝对定位实现"><a href="#利用绝对定位实现" class="headerlink" title="利用绝对定位实现"></a>利用绝对定位实现</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">body</span> <span class="token punctuation">{</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.header</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.container</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.footer</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用flex布局实现"><a href="#利用flex布局实现" class="headerlink" title="利用flex布局实现"></a>利用flex布局实现</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">html,body</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">body</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.header</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.container</span> <span class="token punctuation">{</span>  <span class="token property">flex-grow</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.footer</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的元素隐藏方式</title>
      <link href="/2022/08/16/chang-jian-de-yuan-su-yin-cang-fang-shi/"/>
      <url>/2022/08/16/chang-jian-de-yuan-su-yin-cang-fang-shi/</url>
      
        <content type="html"><![CDATA[<ol><li>使用 <code>display:none;</code>隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li>使用 <code>visibility:hidden;</code>隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li>使用 <code>opacity:0;</code>将元素的不透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且<mark>能够响应元素绑定的监听事件</mark>。</li><li>通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li>通过 <code>z-index</code> 负值，来使其他元素遮盖住该元素，以此来实现隐藏。</li><li>通过 <code>clip</code>/<code>clip-path</code> 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li>通过 <code>transform:scale(0,0)</code>来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圣杯布局和双飞翼布局</title>
      <link href="/2022/08/16/sheng-bei-bu-ju-he-shuang-fei-yi-bu-ju/"/>
      <url>/2022/08/16/sheng-bei-bu-ju-he-shuang-fei-yi-bu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是圣杯布局和双飞翼布局？"><a href="#什么是圣杯布局和双飞翼布局？" class="headerlink" title="什么是圣杯布局和双飞翼布局？"></a>什么是圣杯布局和双飞翼布局？</h2><p>圣杯布局和双飞翼布局是一样的，都是两边固定宽度，中间自适应的三栏布局，中间栏要放在文档流前面以优先渲染。不过两者实现方式上有些区别。</p><p><img src="https://img-blog.csdnimg.cn/20200525170807466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTU5MDYy,size_16,color_FFFFFF,t_70" alt="圣杯布局"></p><p><img src="https://img-blog.csdnimg.cn/20200525170837248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTU5MDYy,size_16,color_FFFFFF,t_70" alt="双飞翼布局"></p><h2 id="为什么要使用双飞翼布局和圣杯布局"><a href="#为什么要使用双飞翼布局和圣杯布局" class="headerlink" title="为什么要使用双飞翼布局和圣杯布局?"></a>为什么要使用双飞翼布局和圣杯布局?</h2><p>都是为了解决两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。</p><h2 id="原理及代码"><a href="#原理及代码" class="headerlink" title="原理及代码"></a>原理及代码</h2><p><strong>圣杯布局</strong>：为了中间div内容不被遮挡，将中间div设置了左右<code>padding-left</code>和<code>padding-right</code>后，将左右两个div用相对布局<code>position: relative</code>并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>圣杯布局<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token selector">.container</span> <span class="token punctuation">{</span><span class="token property">border</span><span class="token punctuation">:</span> 1px solid yellow<span class="token punctuation">;</span><span class="token property">padding</span><span class="token punctuation">:</span> 0 300px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.container div</span> <span class="token punctuation">{</span><span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 中间自适应 */</span><span class="token selector">.main</span> <span class="token punctuation">{</span><span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span> #FFFF00<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 左 */</span><span class="token selector">.left</span> <span class="token punctuation">{</span><span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span> darkcyan<span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span> -300px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 右 */</span><span class="token selector">.right</span> <span class="token punctuation">{</span><span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span> #0000FF<span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span> -300px<span class="token punctuation">;</span><span class="token property">right</span><span class="token punctuation">:</span> -300px<span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 圣杯布局 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 中间自适应 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 两边定宽 --&gt;</span><span class="token comment">&lt;!-- 左 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 右 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双飞翼布局</strong>：为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用<code>margin-left</code>和<code>margin-right</code>为左右两栏div留出位置。多了1个div，少用大致4个css属性（圣杯布局中间div的<code>padding-left</code>和<code>padding-right</code>这2个属性，加上左右两个div用相对布局<code>position: relative</code>及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用<code>margin-left</code>和<code>margin-right</code>共2个属性，6-2=4）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>双飞翼布局<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token selector">.col</span> <span class="token punctuation">{</span><span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#main</span> <span class="token punctuation">{</span><span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> #ccc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#main-wrap</span> <span class="token punctuation">{</span><span class="token property">margin</span><span class="token punctuation">:</span> 0 190px 0 190px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#left</span> <span class="token punctuation">{</span><span class="token property">width</span><span class="token punctuation">:</span> 190px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> #0000FF<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#right</span> <span class="token punctuation">{</span><span class="token property">width</span><span class="token punctuation">:</span> 190px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span> -190px<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> #FF0000<span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 双飞翼布局 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main-wrap<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>#main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>#left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>#right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="两种布局实现方式对比"><a href="#两种布局实现方式对比" class="headerlink" title="两种布局实现方式对比"></a>两种布局实现方式对比</h2><ul><li>两种布局方式都是把主列放在文档流最前面，使主列优先加载。</li><li>两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。</li><li>两种布局方式的不同之处在于如何处理中间主列的位置： <strong>圣杯布局是利用父容器的左、右内边距+两个从列相对定位</strong>； <strong>双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整</strong>。</li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 预处理器/后处理器</title>
      <link href="/2022/08/16/css-yu-chu-li-qi-hou-chu-li-qi/"/>
      <url>/2022/08/16/css-yu-chu-li-qi-hou-chu-li-qi/</url>
      
        <content type="html"><![CDATA[<p>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。</p><p>预处理器例如：<mark>LESS</mark>、<mark>Sass</mark>、<mark>Stylus</mark>，用来预编译Sass或less ，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p><p>CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。</p><p>后处理器例如：<mark>PostCSS</mark>，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>margin 和 padding 分别适合什么场景</title>
      <link href="/2022/08/16/margin-he-padding-fen-bie-gua-he-shi-me-chang-jing/"/>
      <url>/2022/08/16/margin-he-padding-fen-bie-gua-he-shi-me-chang-jing/</url>
      
        <content type="html"><![CDATA[<p><code>margin</code>是用来隔开<mark>元素与元素</mark>的间距；<code>padding</code>是用来隔开<mark>元素与内容</mark>的间隔。<br><code>margin</code>用于布局分开元素使元素与元素互不相干。<br><code>padding</code>用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</p><h3 id="何时应当使用margin"><a href="#何时应当使用margin" class="headerlink" title="何时应当使用margin"></a>何时应当使用margin</h3><ul><li>需要在border外侧添加空白时。</li><li>空白处不需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</li></ul><h3 id="何时应当时用padding"><a href="#何时应当时用padding" class="headerlink" title="何时应当时用padding"></a>何时应当时用padding</h3><ul><li>需要在border内测添加空白时。</li><li>空白处需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。</li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 优化、提高性能的方法</title>
      <link href="/2022/08/15/css-you-hua-ti-gao-xing-neng-de-fang-fa/"/>
      <url>/2022/08/15/css-you-hua-ti-gao-xing-neng-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="加载性能"><a href="#加载性能" class="headerlink" title="加载性能"></a>加载性能</h2><ol><li><strong>css压缩</strong>：将写好的css进行打包压缩，可以减少很多的体积。</li><li><strong>css单一样式</strong>：当需要下边距和左边距的时候，很多时候选择:<code>margin:top 0 bottom 0;</code>但<code>margin-bottom:bottom;</code> <code>margin-left:left;</code>执行的效率更高。</li><li><strong>减少使用@import,而建议使用link</strong>，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ol><h2 id="选择器性能"><a href="#选择器性能" class="headerlink" title="选择器性能"></a>选择器性能</h2><ol><li><p>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择器是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p></li><li><p>如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</p></li><li><p>避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</p></li><li><p>尽量少的去对标签进行选择，而是用class。</p></li><li><p>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</p></li><li><p>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p></li></ol><h2 id="渲染性能"><a href="#渲染性能" class="headerlink" title="渲染性能"></a>渲染性能</h2><ol><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li><li>属性值为0时，不加单位。</li><li>属性值为浮动小数0.**，可以省略小数点之前的0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li><li>不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li></ol><h2 id="可维护性、健壮性"><a href="#可维护性、健壮性" class="headerlink" title="可维护性、健壮性"></a>可维护性、健壮性</h2><ol><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清除浮动</title>
      <link href="/2022/08/15/qing-chu-fu-dong/"/>
      <url>/2022/08/15/qing-chu-fu-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要清除浮动？"><a href="#为什么需要清除浮动？" class="headerlink" title="为什么需要清除浮动？"></a>为什么需要清除浮动？</h2><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现<strong>“高度塌陷”</strong>。</p><p>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</p><h2 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h2><ol><li>使用clear属性清除浮动。</li></ol><h3 id="使用-clear-属性清除浮动的原理"><a href="#使用-clear-属性清除浮动的原理" class="headerlink" title="使用 clear 属性清除浮动的原理"></a>使用 clear 属性清除浮动的原理</h3><p>使用clear属性清除浮动，其语法如下：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">clear</span><span class="token punctuation">:</span>none|left|right|both<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果单看字面意思，<code>clear:left</code>应该是“清除左浮动”，<code>clear:right</code>应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性的解释是：<mark>“元素盒子的边不能和前面的浮动元素相邻。”</mark>，我们对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是<code>left</code>，要么是<code>right</code>，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当<code>clear:left</code>有效的时候，<code>clear:right</code>必定无效，也就是此时<code>clear:left</code>等同于设置<code>clear:both</code>；同样地，<code>clear:right</code>如果有效也是等同于设置<code>clear:both</code>。由此可见，<code>clear:left</code>和<code>clear:right</code>这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用<code>clear:both</code>吧。</p><p>一般使用伪元素的方式清除浮动:</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.clear::before,  // 解决外边距重叠的问题.clear::after</span><span class="token punctuation">{</span>   // 解决高度塌陷的问题<span class="token property">content</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">;</span><span class="token property">display</span><span class="token punctuation">:</span>table<span class="token punctuation">;</span> //也可以是<span class="token string">'block'</span>，或者是<span class="token string">'list-item'</span><span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>clear属性只有块级元素才有效的，而<code>::after</code>等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置<code>display</code>属性值的原因。</p><ol><li>使用BFC块级格式化上下文来清除浮动。<br>因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC 规范</title>
      <link href="/2022/08/15/bfc-gui-fan/"/>
      <url>/2022/08/15/bfc-gui-fan/</url>
      
        <content type="html"><![CDATA[<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>块级格式化上下文（<code>Block Formatting Context</code>，<code>BFC</code>）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲</p><ul><li>BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。</li><li>如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</li></ul><p><i>创建BFC:</i></p><ol><li>根元素或包含根元素的元素</li><li>浮动元素<code>float＝left|right或inherit（≠none）</code></li><li>绝对定位元素<code>position = absolute</code>或<code>fixed</code></li><li><code>display＝inline-block|flex|inline-flex|table-cell</code>或<code>table-caption</code></li><li><code>overflow＝hidden|auto</code>或<code>scroll(≠visible)</code></li></ol><p>一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，<code>display</code>属性的值为<code>inline-block</code>、<code>flex</code>这些属性时也会创建BFC。还有就是元素的<code>overflow</code>的值不为<code>visible</code>时都会创建BFC。</p><h3 id="IFC-是什么"><a href="#IFC-是什么" class="headerlink" title="IFC 是什么?"></a>IFC 是什么?</h3><p>IFC指的是<ins>行级格式化上下文</ins>，它有这样的一些布局规则：</p><ol><li>行级上下文内部的盒子会在水平方向，一个接一个地放置。</li><li>当一行不够的时候会自动切换到下一行。</li><li>行级上下文的高度由内部最高的内联盒子的高度决定。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>display、position和float的相互关系</title>
      <link href="/2022/08/15/display-position-he-float-de-xiang-hu-guan-xi/"/>
      <url>/2022/08/15/display-position-he-float-de-xiang-hu-guan-xi/</url>
      
        <content type="html"><![CDATA[<ol><li>首先我们判断<code>display</code>属性是否为<code>none</code>，如果为<code>none</code>，则<code>position</code>和<code>float</code>属性的值不影响元素最后的表现。</li><li>然后判断<code>position</code>的值是否为<code>absolute</code>或者<code>fixed</code>，如果是，则<code>float</code>属性失效，并且<code>display</code>的值应该被设置为<code>table</code>或者<code>block</code>，具体转换需要看初始转换值。</li><li>如果<code>position</code>的值不为<code>absolute</code>或者<code>fixed</code>，则判断<code>float</code>属性的值是否为<code>none</code>，如果不是，则<code>display</code>的值则按上面的规则转换。注意，如果<code>position</code>的值为<code>relative</code>并且<code>float</code>属性的值存在，则<code>relative</code>相对于浮动后的最终位置定位。</li><li>如果<code>float</code>的值为<code>none</code>，则判断元素是否为根元素，如果是根元素则<code>display</code>属性按照上面的规则转换，如果不是，则保持指定的<code>display</code>属性值不变。</li></ol><p>总的来说，可以把它看作是一个类似优先级的机制，<code>position:absolute</code>和<code>position:fixed</code>优先级最高，有它存在的时候，浮动不起作用，<code>display</code>的值也需要调整；其次，元素的<code>float</code>特性的值不是<code>none</code>的时候或者它是根元素的时候，调整<code>display</code>的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，<code>display</code>特性值同设置值。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用图片 base64 编码的优点和缺点</title>
      <link href="/2022/08/15/shi-yong-tu-pian-base64-bian-ma-de-you-dian-he-que-dian/"/>
      <url>/2022/08/15/shi-yong-tu-pian-base64-bian-ma-de-you-dian-he-que-dian/</url>
      
        <content type="html"><![CDATA[<p>base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url属性。</p><p>使用base64的<mark>优点</mark>是：</p><ol><li>减少一个图片的HTTP请求</li></ol><p>使用base64的<mark>缺点</mark>是：</p><ol><li>根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。</li><li>使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如<code>HTML</code>或者<code>CSS</code>，这相比于直接缓存图片的效果要差很多。</li><li>兼容性的问题，ie8以前的浏览器不支持。</li></ol><p>一般一些网站的小图标可以使用base64图片来引入。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>width:auto 和 width:100%的区别</title>
      <link href="/2022/08/15/width-auto-he-width-100-de-qu-bie/"/>
      <url>/2022/08/15/width-auto-he-width-100-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><code>width:100%</code>会使元素box的宽度等于<mark>父元素</mark>的<code>content box</code>的宽度。</p><p><code>width:auto</code>会使元素撑满整个父元素，<code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code>区域会自动分配水平空间。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>visibility 属性</title>
      <link href="/2022/08/15/visibility-shu-xing/"/>
      <url>/2022/08/15/visibility-shu-xing/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>visible</code></td><td><strong>默认值</strong>。元素是可见的。</td></tr><tr><td><code>hidden</code></td><td>元素是不可见的。但是其他元素的布局不改变，相当于此元素变成透明。</td></tr><tr><td><code>collapse</code></td><td>当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。（与将 <code>display: none</code> 用于表格的行/列上的效果相当）。但是，仍会计算其他行和列的大小，就好像折叠的行或列中的单元格一样。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为<code>hidden</code>。</td></tr><tr><td><code>inherit</code></td><td>规定应该从父元素继承 visibility 属性的值。</td></tr></tbody></table><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是包含块</title>
      <link href="/2022/08/15/shi-me-shi-bao-han-kuai/"/>
      <url>/2022/08/15/shi-me-shi-bao-han-kuai/</url>
      
        <content type="html"><![CDATA[<p>包含块（containing block）就是元素用来计算和定位的一个框。</p><p>当我们设置百分比单位时，元素的值是参照于包含块的指定值进行计算的。</p><p>包含块就是包含了当前元素的块元素，根据不同的情况元素的包含块也不同：</p><p><strong>1. 普通元素的包含块就是离他最近的祖先块元素</strong></p><p>以下边的网页为例</p><ul><li><code>body</code>的包含块是<code>html</code></li><li><code>html</code>的包含块是<code>初始包含块</code></li></ul><p><strong>2. 对于设置了绝对定位的元素（<code>position</code>为<code>absolute</code>）</strong></p><ul><li>它的包含块就是离它最近的开启了定位的祖先元素</li><li>如果所有的祖先元素都没有开启定位，则它的包含块就是初始包含块</li><li>绝对定位元素是参照于它的包含块进行定位的</li></ul><p>如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="/2022/08/09/fang-dou-he-jie-liu/"/>
      <url>/2022/08/09/fang-dou-he-jie-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次。</p><h3 id="手写防抖函数"><a href="#手写防抖函数" class="headerlink" title="手写防抖函数"></a>手写防抖函数</h3><p>假设我们要点击一个按钮新增一条信息，当然我们不希望每次点击都调用接口新增，我们希望多次点击只新增一次。<br><img src="https://img-blog.csdnimg.cn/4839ac1149844caa942cdfd72f696170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YmN56uv6bKB54-t,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>首先我们先简单的模拟一个按钮被点击的过程。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> addBtn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'添加数据'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>addBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span>addOne<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为我们需要对执行的事件进行处理所以接下来我们需要封装一下addOne函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> addBtn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'添加数据'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fun</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>addBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token function">debounce</span><span class="token punctuation">(</span>addOne<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面我们用闭包处理了一下addOne函数，接下来我们需要添加一个延时器setTimeout来倒计时，当我们点击按钮后过2s再执行。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fun<span class="token punctuation">,</span>time</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>            <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>time<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>addBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token function">debounce</span><span class="token punctuation">(</span>addOne<span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们的一个防抖功能就完成了，但是这还没完，如果我们在addOne()打印this会发现我们这样执行的this是指向Window的。</p><p>这当然不是我们所希望的，我们需要使用apply来改变this指向，再者就是我们需要考虑到执行函数的参数，因为不同的函数肯定会有不同的参数传入,对于参数我们可以使用arguments处理。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fun<span class="token punctuation">,</span>time</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> timer  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments    timer<span class="token operator">=</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>      <span class="token function">fun</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>time<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。</p><h3 id="手写节流函数"><a href="#手写节流函数" class="headerlink" title="手写节流函数"></a>手写节流函数</h3><p><strong>原理：定义一个开关变量flag，调用的时候把它赋值为true，然后再写一个定时器，待定时器结束后再赋值为false。 再定时器还未结束期间，再次调用函数时判定flag，为true的话直接return就行。</strong></p><p>极简版</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token comment">// true 表示上次执行未结束</span>    flag <span class="token operator">=</span> <span class="token boolean">true</span>    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        flag <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 结束后重新设置为false</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment">// 测试函数</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">}</span> window<span class="token punctuation">.</span><span class="token function-variable function">onscroll</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// test() // 不用节流的话，页面滚动一直在调用</span>    <span class="token function">throttle</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// 加上节流，即使页面一直滚动，也只会每隔一秒执行一次test函数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化版</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 把变量放函数里面，避免全局污染</span>    <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token keyword">let</span> arg <span class="token operator">=</span> arguments <span class="token comment">// 此处为fn函数的参数</span>        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> arg<span class="token punctuation">)</span>            flag <span class="token operator">=</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">let</span> throttleTest <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> window<span class="token punctuation">.</span><span class="token function-variable function">onscroll</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">throttleTest</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向数据绑定</title>
      <link href="/2022/08/09/shuang-xiang-shu-ju-bang-ding/"/>
      <url>/2022/08/09/shuang-xiang-shu-ju-bang-ding/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是双向绑定"><a href="#什么是双向绑定" class="headerlink" title="什么是双向绑定"></a>什么是双向绑定</h2><p>我们先从单向绑定切入，单向绑定非常简单，就是把<code>Model</code>绑定到<code>View</code>，当我们用<code>JavaScript</code>代码更新<code>Model</code>时，<code>View</code>就会自动更新。双向绑定就很容易联想到了，在单向绑定的基础上，用户更新了<code>View</code>，<code>Model</code>的数据也自动被更新了，这种情况就是双向绑定，举个栗子：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6670e41c23314a98c684055933075a18.png"></p><p>当用户填写表单时，<code>View</code>的状态就被更新了，如果此时可以自动更新<code>Model</code>的状态，那就相当于我们把<code>Model</code>和<code>View</code>做了双向绑定关系图如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8f42b7a30579e7d246baa0617bfce5ad.png"></p><h2 id="双向绑定的原理是什么"><a href="#双向绑定的原理是什么" class="headerlink" title="双向绑定的原理是什么"></a>双向绑定的原理是什么</h2><p>我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成</p><ul><li>数据层（Model）：应用的数据及业务逻辑</li><li>视图层（View）：应用的展示效果，各类UI组件</li><li>业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来</li></ul><p>而上面的这个分层的架构方案，可以用一个专业术语进行称呼：<code>MVVM</code><br>这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理。</p><h3 id="理解ViewModel"><a href="#理解ViewModel" class="headerlink" title="理解ViewModel"></a>理解ViewModel</h3><p>它的主要职责就是：</p><ul><li>数据变化后更新视图</li><li>视图变化后更新数据</li></ul><p>当然，它还有两个主要部分组成：</p><ul><li>监听器（Observer）：对所有数据的属性进行监听</li><li>解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li></ul><h2 id="实现双向绑定"><a href="#实现双向绑定" class="headerlink" title="实现双向绑定"></a>实现双向绑定</h2><p>先来看看Vue中的双向绑定流程是什么的：</p><ol><li><code>new Vue()</code>首先执行初始化，对<code>data</code>执行响应化处理，这个过程发生<code>Observe</code>中</li><li>同时对模板执行编译，找到其中动态绑定的数据，从<code>data</code>中获取并初始化视图，这个过程发生在<code>Compile</code>中</li><li>同时定义⼀个更新函数和<code>Watcher</code>，将来对应数据变化时<code>Watcher</code>会调用更新函数</li><li>由于<code>data</code>的某个<code>key</code>在⼀个视图中可能出现多次，所以每个<code>key</code>都需要⼀个管家<code>Dep</code>来管理多个<code>Watcher</code></li><li>将来<code>data</code>中数据⼀旦发生变化，会首先找到对应的<code>Dep</code>，通知所有<code>Watcher</code>执行更新函数</li></ol><p>流程图如下：<br><img src="https://img-blog.csdnimg.cn/img_convert/83f9f37a6fde9f3c4278bcb0e07112ca.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>先来一个构造函数：执行初始化，对<code>data</code>执行响应化处理</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Vue</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$options <span class="token operator">=</span> options<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$data <span class="token operator">=</span> options<span class="token punctuation">.</span>data<span class="token punctuation">;</span>              <span class="token comment">// 对data选项做响应式处理  </span>    <span class="token function">observe</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 代理data到vm上  </span>    <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 执行编译  </span>    <span class="token keyword">new</span> <span class="token class-name">Compile</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>el<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对<code>data</code>选项执行响应化具体操作</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">"object"</span> <span class="token operator">||</span> obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编译Compile"><a href="#编译Compile" class="headerlink" title="编译Compile"></a>编译<code>Compile</code></h3><p>对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</p><p><img src="https://img-blog.csdnimg.cn/img_convert/05378e819de9e8632a5e5f50fce69a43.png"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Compile</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取dom  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">compile</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> childNodes <span class="token operator">=</span> el<span class="token punctuation">.</span>childNodes<span class="token punctuation">;</span>       Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>childNodes<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 遍历子元素  </span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isElement</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 判断是否为节点  </span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"编译元素"</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>nodeName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isInterpolation</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"编译插值⽂本"</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断是否为插值文本 {{}}  </span>      <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>childNodes <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>childNodes<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 判断是否有子元素  </span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对子元素进行递归遍历  </span>      <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">isElement</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> node<span class="token punctuation">.</span>nodeType <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">isInterpolation</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> node<span class="token punctuation">.</span>nodeType <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\{\{(.*)\}\}</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>视图中会用到<code>data</code>中某<code>key</code>，这称为依赖。同⼀个<code>key</code>可能出现多次，每次都需要收集出来用⼀个<code>Watcher</code>来维护它们，此过程称为依赖收集多个<code>Watcher</code>需要⼀个<code>Dep</code>来管理，需要更新时由<code>Dep</code>统⼀通知</p><p><img src="https://img-blog.csdnimg.cn/img_convert/43db0950b0c8075c166230862cd559e0.png"></p><p>实现思路</p><ol><li><code>defineReactive</code>时为每⼀个<code>key</code>创建⼀个<code>Dep</code>实例</li><li>初始化视图时读取某个<code>key</code>，例如<code>name1</code>，创建⼀个<code>watcher1</code></li><li>由于触发<code>name1</code>的<code>getter</code>方法，便将<code>watcher1</code>添加到<code>name1</code>对应的<code>Dep</code>中</li><li>当<code>name1</code>更新，<code>setter</code>触发时，便可通过对应<code>Dep</code>通知其管理所有<code>Watcher</code>更新</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 负责更新视图  </span><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> updater</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm      <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key      <span class="token keyword">this</span><span class="token punctuation">.</span>updaterFn <span class="token operator">=</span> updater        <span class="token comment">// 创建实例时，把当前实例指定到Dep.target静态属性上  </span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>      <span class="token comment">// 读一下key，触发get  </span>    vm<span class="token punctuation">[</span>key<span class="token punctuation">]</span>      <span class="token comment">// 置空  </span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token punctuation">}</span>      <span class="token comment">// 未来执行dom更新函数，由dep调用的  </span>  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updaterFn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明<code>Dep</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 依赖管理  </span>  <span class="token punctuation">}</span>    <span class="token function">addDep</span><span class="token punctuation">(</span><span class="token parameter">dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">dep</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dep<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建<code>watcher</code>时触发<code>getter</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> updateFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>      Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依赖收集，创建<code>Dep</code>实例</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Dep<span class="token punctuation">.</span>target <span class="token operator">&amp;&amp;</span> dep<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Dep.target也就是Watcher实例  </span>      <span class="token keyword">return</span> val<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通知dep执行更新方法  </span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向数据绑定的优缺点"><a href="#双向数据绑定的优缺点" class="headerlink" title="双向数据绑定的优缺点"></a>双向数据绑定的优缺点</h2><p><strong>优点：</strong>用户在视图上的修改会自动同步到数据模型中去，数据模型中值的变化也会立刻同步到视图中去；无需进行和单向数据绑定的那些相关操作，会简化大量业务无关的代码。</p><p><strong>缺点：</strong>增加了出错时的debug的难度、消耗较大，部署很大网站的时候会出现问题。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex弹性盒子布局</title>
      <link href="/2022/08/08/flex-dan-xing-he-zi-bu-ju/"/>
      <url>/2022/08/08/flex-dan-xing-he-zi-bu-ju/</url>
      
        <content type="html"><![CDATA[<p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex元素（flex item），简称”元素”。</p><p>容器默认存在两根轴：<mark>水平的主轴（main axis）</mark>和<mark>垂直的辅轴（cross axis）</mark>，元素默认沿主轴排列。</p><p>以下6个属性设置在<strong>容器上</strong>:</p><ol><li><code>flex-direction</code>属性决定主轴的方向（即元素的排列方向）。</li><li><code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</li><li><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</li><li><code>justify-content</code>属性定义了元素在主轴上的对齐方式。 可选值：<code>flex-start</code>, <code>flex-end</code>, <code>center</code>, <code>space-around</code>, <code>space-between</code>, <code>stretch</code>。</li><li><code>align-items</code>属性定义元素在辅轴上如何对齐。 可选值：<code>flex-start</code>, <code>flex-end</code>, <code>center</code>, <code>stretch</code></li><li><code>align-content</code>属性定义了多根轴线的对齐方式。如果元素只有一根轴线，该属性不起作用。</li></ol><p>以下6个属性设置在<strong>元素上</strong>：</p><ol><li><code>order</code>属性定义元素的排列顺序。数值越小，排列越靠前，默认为0。</li><li><code>flex-grow</code>属性定义元素的增长系数，默认为0，即如果存在剩余空间，也不放大。</li><li><code>flex-shrink</code>属性定义了项目的缩减系数，默认为1，即如果空间不足，该项目将缩小。</li><li><code>flex-basis</code>属性定义了在分配多余空间之前，元素占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li><code>flex</code>属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li><code>align-self</code>属性允许单个元素有与其他元素不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 的新特性</title>
      <link href="/2022/08/08/css3-de-xin-te-xing/"/>
      <url>/2022/08/08/css3-de-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<p>圆角（<code>border-radius:8px</code>）<br>多列布局（<code>multi-column layout</code>）<br>阴影和反射（<code>Shadow\Reflect</code>）<br>文字特效（<code>text-shadow</code>）<br>文本修饰（<code>Text-decoration</code>）<br>线性渐变（<code>linear-gradient</code>）<br>旋转（<code>transform：rotate</code>）<br>缩放，平移，倾斜，动画，多背景</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>position值的定位原点</title>
      <link href="/2022/08/08/position-zhi-de-ding-wei-yuan-dian/"/>
      <url>/2022/08/08/position-zhi-de-ding-wei-yuan-dian/</url>
      
        <content type="html"><![CDATA[<p><strong><mark>absolute</mark></strong></p><p>生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。</p><p><strong><mark>fixed</mark></strong><br>生成固定定位的元素，相对于浏览器窗口进行定位。</p><p><strong><mark>relative</mark></strong></p><p>生成相对定位的元素，相对于其元素本身所在文档流中的位置进行定位。</p><p><strong><mark>static</mark></strong></p><p>默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。</p><p><strong><mark>inherit</mark></strong></p><p>规定从父元素继承position属性的值。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>display可以设置的值</title>
      <link href="/2022/08/08/display-ke-yi-she-zhi-de-zhi/"/>
      <url>/2022/08/08/display-ke-yi-she-zhi-de-zhi/</url>
      
        <content type="html"><![CDATA[<ol><li><code>block</code>：块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li><code>none</code>：元素不显示，并从文档流中移除。</li><li><code>inline</code>：行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li><li><code>inline-block</code>：默认宽度为内容宽度，可以设置宽高，同行显示。</li><li><code>list-item</code>：像块类型元素一样显示，并添加样式列表标记。</li><li><code>table</code>：此元素会作为块级表格来显示。</li><li><code>inherit</code>：规定应该从父元素继承display属性的值。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何居中div</title>
      <link href="/2022/08/08/ru-he-ju-zhong-div/"/>
      <url>/2022/08/08/ru-he-ju-zhong-div/</url>
      
        <content type="html"><![CDATA[<ol><li><p>水平居中：给 div 设置一个宽度，然后添加 <code>margin:0 auto</code> 属性</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>水平居中，利用 <code>text-align:center</code> 实现</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.container</span> <span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.box</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>让绝对定位的 div 居中</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span> <span class="token comment">/*方便看效果*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li><p>水平垂直居中一</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*确定容器的宽高宽500高300的层设置层的外边距*/</span><span class="token selector">div</span><span class="token punctuation">{</span><span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span><span class="token comment">/*绝对定位*/</span><span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span><span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> -150px 0 0 -250px<span class="token punctuation">;</span><span class="token comment">/*外边距为自身宽高的一半*/</span><span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span><span class="token comment">/*方便看效果*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>水平垂直居中二</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*未知容器的宽高，利用`transform`属性*/</span><span class="token selector">div</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> <span class="token comment">/*相对定位或绝对定位均可*/</span>  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span> <span class="token comment">/*方便看效果*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>水平垂直居中三</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*利用flex布局实际使用时应考虑兼容性*/</span><span class="token selector">.container</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span> <span class="token comment">/*垂直居中*/</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span> <span class="token comment">/*水平居中*/</span><span class="token punctuation">}</span><span class="token selector">.containerdiv</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span> <span class="token comment">/*方便看效果*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>水平垂直居中四</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*利用text-align:center和vertical-align:middle属性*/</span><span class="token selector">.container</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span>  <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.container::after</span> <span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.box</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>  <span class="token property">white-space</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 中可以继承的属性</title>
      <link href="/2022/08/08/css-zhong-ke-yi-ji-cheng-de-shu-xing/"/>
      <url>/2022/08/08/css-zhong-ke-yi-ji-cheng-de-shu-xing/</url>
      
        <content type="html"><![CDATA[<p>当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应该是在该属性本身的定义中的默认值）。</p><p>当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial value（该值在该属性的概述里被指定）。</p><p>有继承性的属性：</p><ol><li><p><strong>字体系列属性</strong><br><code>font</code>、<code>font-family</code>、<code>font-weight</code>、<code>font-size</code>、<code>font-style</code>、<code>font-variant</code>、<code>font-stretch</code>、<code>font-size-adjust</code></p></li><li><p><strong>文本系列属性</strong><br><code>text-indent</code>、<code>text-align</code>、<code>text-shadow</code>、<code>line-height</code>、<code>word-spacing</code>、<code>letter-spacing</code>、<code>text-transform</code>、<code>direction</code>、<code>color</code></p></li><li><p><strong>表格布局属性</strong><br><code>caption-side</code>、<code>border-collapse</code>、<code>empty-cells</code></p></li><li><p><strong>列表属性</strong><br><code>list-style-type</code>、<code>list-style-image</code>、<code>list-style-position</code>、<code>list-style</code></p></li><li><p><strong>光标属性</strong><br><code>cursor</code></p></li><li><p><strong>元素可见性</strong><br><code>visibility</code></p></li><li><p>还有一些不常用的<br>speak，page，设置嵌套引用的引号类型quotes等属性</p></li></ol><p>注意：当一个属性不是继承属性时，可以使用<code>inherit</code>关键字指定一个属性应从父元素继承它的值，<code>inherit</code>关键字用于显式地指定继承性，可用于任何继承性/非继承性属性。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 选择器</title>
      <link href="/2022/08/08/css-xuan-ze-qi/"/>
      <url>/2022/08/08/css-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h2><ul><li>id选择器（<code>#myid</code>）</li><li>类选择器（<code>.myclassname</code>）</li><li>标签选择器（<code>div</code>,<code>h1</code>,<code>p</code>）</li><li>后代选择器（<code>h1</code>,<code>p</code>）</li><li>子选择器（<code>ul</code>&gt;<code>li</code>）</li><li>兄弟选择器（所有）（<code>li</code>~ <code>a</code>）</li><li>相邻兄弟选择器（<code>li</code>+<code>a</code>）</li><li>属性选择器（<code>a[rel="external"]</code>）</li><li>伪类选择器（<code>a:hover</code>,<code>li:nth-child</code>）</li><li>伪元素选择器（<code>::before</code>、<code>::after</code>）</li><li>通配符选择器（<code>*</code>）</li></ul><h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><p><ins>::before 和:after 中双冒号和单冒号有什么区别？</ins></p><p>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）</p><p>想让插入的内容出现在其它内容前，使用<code>::before</code>，否者，使用<code>::after</code>；<br>在代码顺序上，<code>::after</code>生成的内容也比<code>::before</code>生成的内容靠后。<br>如果按堆栈视角，<code>::after</code>生成的内容会在<code>::before</code>生成的内容之上。</p><p><ins>伪类与伪元素的区别</ins></p><p>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p><p>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过<code>:hover</code>来描述这个元素的状态。</p><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过<code>::before</code>来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p><p><ins>CSS3 新增伪类</ins></p><ol><li><code>elem:nth-child(n)</code>选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数值，也可以接受函数。</li><li><code>elem:nth-last-child(n)</code>作用同上，不过是从后开始查找。</li><li><code>elem:last-child</code>选中最后一个子元素。</li><li><code>elem:only-child</code>如果elem是父元素下唯一的子元素，则选中之。</li><li><code>elem:nth-of-type(n)</code>选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。</li><li><code>elem:first-of-type</code>选中父元素下第一个elem类型元素。</li><li><code>elem:last-of-type</code>选中父元素下最后一个elem类型元素。</li><li><code>elem:only-of-type</code>如果父元素下的子元素只有一个elem类型元素，则选中该元素。</li><li><code>elem:empty</code>选中不包含子元素和内容的elem类型元素。</li><li><code>elem:target</code>选择当前活动的elem元素。</li><li><code>:not(elem)</code>选择非elem元素的每个元素。</li><li><code>:enabled</code>控制表单控件的禁用状态。</li><li><code>:disabled</code>控制表单控件的禁用状态。</li><li><code>:checked</code>单选框或复选框被选中。</li></ol><h2 id="CSS-优先级算法"><a href="#CSS-优先级算法" class="headerlink" title="CSS 优先级算法"></a>CSS 优先级算法</h2><p>CSS的优先级是根据样式声明的特殊性值来判断的。</p><p>选择器的特殊性值分为四个等级，如下：</p><ol><li>内联样式选择器<code>x,0,0,0</code></li><li>ID选择器<code>0,x,0,0</code></li><li>class选择器/属性选择器/伪类选择器<code>0,0,x,0</code></li><li>元素和伪元素选择器<code>0,0,0,x</code></li></ol><p><i>计算方法：</i></p><ol><li>每个等级的初始值为0</li><li>每个等级的叠加为选择器出现的次数相加</li><li>不可进位，比如0,99,99,99</li><li>依次表示为：0,0,0,0</li><li>每个等级计数之间没关联</li><li>等级判断从左向右，如果某一位数值相同，则判断下一位数值</li><li>如果两个优先级相同，则最后出现的优先级高，!important也适用</li><li>通配符选择器的特殊性值为：0,0,0,0</li><li>继承样式优先级最低，通配符样式优先级高于继承样式</li><li><code>!important</code>（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0</li></ol><p>注意：</p><ol><li>样式应用时，css会先查看规则的权重<code>!important</code>，加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。</li><li>特殊性值越大的声明优先级越高。</li><li>相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）。</li><li>部分浏览器由于字节溢出问题出现的进位表现不做考虑。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 的盒子模型</title>
      <link href="/2022/08/08/css-de-he-zi-mo-xing/"/>
      <url>/2022/08/08/css-de-he-zi-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>盒模型：分为<strong>内容（content）、填充（padding）、边界（margin）、边框（border）</strong>四个部分</p><p>有两种盒子模型：</p><ul><li>IE盒模型（border-box）</li><li>W3C标准盒模型（content-box）</li></ul><p>IE盒模型和W3C标准盒模型的区别：</p><ol><li>W3C标准盒模型：属性width，height只包含内容<mark>content</mark>，不包含border和padding。</li><li>IE盒模型：属性width，height包含content、border和padding，指的是<mark>content+padding+border</mark>。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="/2022/08/07/qian-duan-xing-neng-you-hua/"/>
      <url>/2022/08/07/qian-duan-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<p>前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。可以从这些方面来进行优化。</p><p><em>第一个方面是页面的内容方面：</em></p><ol><li>通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。</li><li>通过 DNS 缓存等机制来减少 DNS 的查询次数。</li><li>通过设置缓存策略，对常用不变的资源进行缓存。</li><li>使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。</li><li>通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。</li></ol><p><em>第二个方面是服务器方面:</em></p><ol><li>使用 CDN 服务，来提高用户对于资源请求时的响应速度。</li><li>服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。</li><li>尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie。</li></ol><p><em>第三个方面是 CSS 和 JavaScript 方面:</em></p><ol><li>把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。</li><li>避免使用 <code>@import</code> 标签。</li><li>尽量把 js 脚本放在页面底部或者使用 <code>defer</code> 或 <code>async</code> 属性，避免脚本的加载和执行阻塞页面的渲染。</li><li>通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>head中的标签</title>
      <link href="/2022/08/07/head-zhong-de-biao-qian/"/>
      <url>/2022/08/07/head-zhong-de-biao-qian/</url>
      
        <content type="html"><![CDATA[<p><code>&lt;head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器。<code>&lt;head&gt;</code> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</p><p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<code>&lt;base&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code>, 以及 <code>&lt;title&gt;</code>。</p><p><code>&lt;title&gt;</code> 定义文档的标题，它是 <strong>head 部分中唯一必需的元素</strong>。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器架构</title>
      <link href="/2022/08/06/liu-lan-qi-jia-gou/"/>
      <url>/2022/08/06/liu-lan-qi-jia-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2><p>浏览器本质上也是一个软件，它运行于操作系统之上，一般来说会在特定的一个端口开启一个进程去运行这个软件，开启进程之后，计算机为这个进程分配CPU资源、运行时内存，磁盘空间以及网络资源等等，通常会为其指定一个PID来代表它。</p><p>浏览器分为两种架构：</p><ul><li>单进程架构（线程间通信）</li><li>多进程架构（进程间IPC通信）</li></ul><p>如果<strong>浏览器单进程架构的话，需要在一个进程内做到网络、调度、UI、存储、GPU、设备、渲染、插件等等任务</strong>，通常来说可以为每个任务开启一个线程，形成单进程多线程的浏览器架构。</p><p>但是由于这些功能的日益复杂，例如将网络，存储，UI放在一个线程中的话，执行效率和性能越来越低下，不能再向下拆分出类似“线程”的子空间。</p><p>因此，<strong>为了逐渐强化浏览器的功能，于是产生了多进程架构的浏览器，可以将网络、调度、UI、存储、GPU、设备、渲染、插件等等任务分配给多个单独的进程，在每一个单独的进程内，又可以拆分出多个子线程，极大程度地强化了浏览器。</strong></p><p>Chrome多进程架构主要包括以下4个进程：</p><ul><li>Browser进程（负责地址栏、书签栏、前进后退、网络请求、文件访问等）</li><li>Renderer进程（负责一个Tab内所有和网页渲染有关的所有事情，是最核心的进程）</li><li>GPU进程（负责GPU相关的任务）</li><li>Plugin进程（负责Chrome插件相关的任务）</li></ul><p>Chrome 多进程架构的优缺点<br><mark>优点：</mark></p><ul><li>每一个Tab就是要给单独的进程</li><li>由于每个Tab都有自己独立的Renderer进程，因此某一个Tab出问题不会影响其它Tab</li></ul><p><mark>缺点：</mark></p><ul><li>Tab间内存不共享，不同进程内存包含相同内容</li></ul><p>前端最核心的渲染（Renderer）进程包含4个线程：</p><ul><li><strong>主线程（Main thread）(下载资源、执行js、计算样式、进行布局、绘制合成)</strong><ul><li>下载资源：主线程可以通过Browser进程的network线程下载图片，css，js等渲染DOM需要的资源文件。</li><li>执行JS：<strong>主线程在遇到<code>&lt;script&gt;</code>标签时，会下载并且执行js，执行js时，为了避免改变DOM的结构，解析HTML停滞，js执行完成后继续解析HTML。正是因为JS执行会阻塞UI渲染，而JS又是浏览器的一哥，因此浏览器常常被看做是单线程的。</strong></li><li>计算样式：主线程会基于CSS选择器或者浏览器默认样式去进行样式计算，最终生成Computed Style。</li><li>进行布局：主线程计算好样式以后，可以确定元素的位置信息以及盒模型信息，对元素进行布局。</li><li>进行绘制：主线程根据先后顺序以及层级关系对元素进行渲染，通常会生成多个图层。</li><li>最终合成：主线程将渲染后的多个frame（帧）合成，类似flash的帧动画和PS的图层。</li></ul></li><li>光栅线程（Raster thread）</li><li>合成线程（Compositor thread）</li><li>工作线程（Worker thread）</li></ul><p><img src="https://s2.loli.net/2022/08/06/yCJ1adtHSZQiBjW.png" alt="渲染进程包含的4个线程"></p><h2 id="单线程js"><a href="#单线程js" class="headerlink" title="单线程js"></a>单线程js</h2><p><em>Chrome中JavaScript运行的位置在哪里呢？</em><br><strong>渲染进程（Renderer Process）中的主线程（Main Thread）</strong></p><p><em>单线程js属于浏览器的哪个进程？</em><br>单线程的js → 主线程（Main Thread）→ <strong>渲染进程（Renderer Process）</strong></p><p><em>js为什么要设计成单线程的？</em><br>其实更为严谨的表述是：“浏览器中的js执行和UI渲染是在一个线程中顺序发生的。”<br>这是因为在渲染进程的主线程在解析HTML生成DOM树的过程中，如果此时执行JS，主线程会主动暂停解析HTML，先去执行JS，等JS解析完成后，再继续解析HTML。</p><p><em>那么为什么要“主线程会主动暂停解析HTML，先去执行JS，再继续解析HTML呢”？</em></p><p><strong>这是主线程在解析HTML生成DOM树的过程中会执行<code>style</code>，<code>layout</code>，<code>render</code>以及<code>composite</code>的操作，而JS可以操作DOM，CSSOM，会影响到主线程在解析HTML的最终渲染结果，最终页面的渲染结果将变得不可预见。</strong></p><p>如果主线程一边解析HTML进行渲染，JS同时在操作DOM或者CSSOM，结果会分为以下情况：</p><ul><li>以主线程解析HTML的渲染结果为准</li><li>以JS同时在操作DOM或者CSSOM的渲染结果为准</li></ul><p>考虑到最终页面的渲染效果的一致性，所以js在浏览器中的实现，被设计成为了JS执行阻塞UI渲染型。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环可以拆为“事件”+“循环”。</p><p>先来聊聊“事件”：</p><ul><li>click、mouseover等等交互事件</li><li>事件冒泡、事件捕获、事件委托等等</li><li>addEventListener、removeEventListener()</li><li>CustomEvent（自定义事件实现自定义交互）</li><li>EventEmitter、EventBus（on，emit，once，off）</li><li>第三方库的事件系统</li></ul><p>有事件，就有<strong>事件处理器</strong>：在事件处理器中，我们会应对这个事件做一些特殊操作。</p><p>如果我们的主线程只是静态的，没有循环的话，可以用js伪代码将其表述为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hello World！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hello JavaScript！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行完一次mainThread()之后，这段代码就无效了，mainThread并不是一种激活状态，对于I/O事件是没有办法捕获到的。</p><p>因此对事件加入了“循环”，将渲染进程的主线程变为激活状态，可以用js伪代码表述如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// click event</span><span class="token keyword">function</span> <span class="token function">clickTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"我点击按钮了"</span><span class="token punctuation">}</span><span class="token comment">// 可以是while循环</span><span class="token keyword">function</span> <span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">clickTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>“通知click事件监听器”<span class="token punctuation">)</span> <span class="token punctuation">}</span>        clickTrigger <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以是for循环：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">clickTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>“通知click事件监听器”<span class="token punctuation">)</span> <span class="token punctuation">}</span>    clickTrigger <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在事件监听器中做出响应：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"多亏了事件循环，我（浏览器）才能知道用户做了什么操作"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列可以拆为“消息”+“队列”。 消息可以理解为用户I/O；队列就是先进先出的数据结构。 而消息队列，则是用于连接用户I/O与事件循环的桥梁。</p><p><strong>队列数据结构图</strong></p><p><img src="https://s2.loli.net/2022/08/06/mUBnAaTzV17hQb5.png" alt="队列数据结构图"></p><p><strong>入队出队图</strong></p><p><img src="https://s2.loli.net/2022/08/06/orNHakKW6p7RFi5.png" alt="入队出队图"></p><p><em>在js中，如何发现出队列FIFO的特性？</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 定义一个队列</span><span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 入队</span>queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// queue[1,2,3,4]</span><span class="token comment">// 出队</span>queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 queue [2,3,4]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设用户做出了”click button1”,”click button3”,”click button 2”的操作。 事件队列定义为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> taskQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"click button1"</span><span class="token punctuation">,</span><span class="token string">"click button3"</span><span class="token punctuation">,</span><span class="token string">"click button 2"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">.</span>length<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    taskQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 任务依次出队</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>任务依次出队： <code>click button1</code> <code>click button3</code> <code>click button 2</code></p><p>此时由于mainThread有事件循环，它会被浏览器渲染进程的主线程事件循环系统捕获，并在对应的事件处理器做出响应。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">button1<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click button1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>button2<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click button 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>button3<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click button3"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依次打印：”click button1”，”click button3”，”click button 2”。</p><p>因此，<strong>可以将消息队列理解为连接用户I/O操作和浏览器事件循环系统的任务队列。</strong></p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p><strong>宏任务</strong></p><p>(macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p><p><strong>微任务</strong></p><p>microtask,可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。</p><h3 id="哪些属于宏任务？"><a href="#哪些属于宏任务？" class="headerlink" title="哪些属于宏任务？"></a>哪些属于宏任务？</h3><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>requestAnimationFrame</li><li>I/O</li><li>UI渲染</li></ul><h3 id="哪些属于微任务？"><a href="#哪些属于微任务？" class="headerlink" title="哪些属于微任务？"></a>哪些属于微任务？</h3><ul><li>Promise</li><li>MutationObserver</li><li>process.nextTick</li><li>queueMicrotask</li></ul><h2 id="事件循环，消息队列与宏任务、微任务之间的关系"><a href="#事件循环，消息队列与宏任务、微任务之间的关系" class="headerlink" title="事件循环，消息队列与宏任务、微任务之间的关系"></a>事件循环，消息队列与宏任务、微任务之间的关系</h2><ul><li>宏任务入队消息队列，可以将消息队列理解为宏任务队列</li><li>每个宏任务内有一个微任务队列，执行过程中微任务入队当前宏任务的微任务队列</li><li>宏任务微任务队列为空时才会执行下一个宏任务</li><li>事件循环捕获队列出队的宏任务和微任务并执行</li></ul><p>事件循环会不断地处理消息队列出队的任务，而宏任务指的就是入队到消息队列中的任务，每个宏任务都有一个微任务队列，宏任务在执行过程中，如果此时产生微任务，那么会将产生的微任务入队到当前的微任务队列中，在当前宏任务的主要任务完成后，会依次出队并执行微任务队列中的任务，直到当前微任务队列为空才会进行下一个宏任务。</p><p><strong>浏览器页面循环系统原理图</strong></p><p><i>消息队列和事件循环</i></p><p>线程的一次执行</p><p><img src="https://s2.loli.net/2022/08/06/MoLs4SiYWHwUxZn.png"></p><p>在线程中引入事件循环</p><p><img src="https://s2.loli.net/2022/08/06/8dKcb7FCwZuaeSW.png"></p><p>渲染进程线程之间发送任务</p><p><img src="https://pic3.zhimg.com/80/v2-8d1b124eb3f15d00599bc377b72d5aba_720w.jpg"><br><img src="https://pic4.zhimg.com/80/v2-1c8a495a5cb1f6b22cd3c742da90aafb_720w.jpg"></p><p>线程模型：队列 + 循环</p><p><img src="https://pic3.zhimg.com/80/v2-7802282fcaaaf814c95b2bafb656e982_720w.jpg"></p><p>跨进程发送消息</p><p><img src="https://pic1.zhimg.com/80/v2-9549cf89a6557150edf1b9ed6ed27274_720w.jpg"></p><p>单个任务执行时间过久</p><p><img src="https://pic4.zhimg.com/80/v2-4874dbf5343d2612b4785366a99c4ffb_720w.jpg"></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器内多个标签页之间的通信</title>
      <link href="/2022/08/05/liu-lan-qi-nei-duo-ge-biao-qian-ye-zhi-jian-de-tong-xin/"/>
      <url>/2022/08/05/liu-lan-qi-nei-duo-ge-biao-qian-ye-zhi-jian-de-tong-xin/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用 <code>WebSocket</code>，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。<br> <code>WebSocket</code>特点：</p><ul><li>保持连接状态，HTTP协议是无状态连接，即请求完毕后就会关闭连接；</li><li>全双工通信，客户端和服务端平等对待，可以互相通信；</li><li>建立在TCP协议之上；</li><li>没有同源共享策略，即可实现跨域共享。</li></ul></li><li><p>使用 <code>SharedWorker</code> （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。</p></li><li><p>可以调用 <code>localStorage</code>、<code>cookies</code> 等本地存储方式，<code>localStorge</code> 另一个浏览上下文里被添加、修改或删除时，它都会触发一个 <code>storage</code> 事件，我们通过监听 <code>storage</code> 事件，控制它的值来进行页面信息通信。<br><code>localStorage</code>特点：</p><ul><li>同域共享存储空间；</li><li>持久化将数据存储在浏览器；</li><li>提供事件监听<code>localStorage</code>变化。</li></ul></li><li><p>如果我们能够获得对应标签页的引用，通过 <code>postMessage</code> 方法也是可以实现多个标签页通信的。</p></li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Label 标签的作用</title>
      <link href="/2022/08/05/label-biao-qian-de-zuo-yong/"/>
      <url>/2022/08/05/label-biao-qian-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<p><code>label</code> 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Number:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“text“</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iframe 的缺点</title>
      <link href="/2022/08/05/iframe-de-que-dian/"/>
      <url>/2022/08/05/iframe-de-que-dian/</url>
      
        <content type="html"><![CDATA[<p><code>iframe</code> 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><h2 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h2><ol><li><code>iframe</code> 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 <code>iframe</code> 的 <code>src</code> 可以避免这种阻塞情况。</li><li>搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。</li><li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li><li>浏览器的后退按钮失效。</li><li>小型的移动设备无法完全显示框架。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookies，sessionStorage 和 localStorage 的区别</title>
      <link href="/2022/08/05/cookies-sessionstorage-he-localstorage-de-qu-bie/"/>
      <url>/2022/08/05/cookies-sessionstorage-he-localstorage-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><code>SessionStorage</code>， <code>LocalStorage</code>， <code>Cookie</code> 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别在于前两者属于 HTML5 WebStorage，创建它们的目的是便于客户端存储数据。而 <code>cookie</code> 是网站为了标示用户身份而储存用户本地终端上的数据（通常经过加密）。<code>cookie</code> 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不要），会在浏览器和服务器间来回传递。</p><table><thead><tr><th></th><th>区别</th></tr></thead><tbody><tr><td>存储大小</td><td><code>cookie</code> 数据大小不能超过 4k。<br><code>sessionStorage</code> 和 <code>localStorage</code> 虽然也有存储大小的限制，但比 <code>cookie</code> 大得多，可以达到 5M 或更大。</td></tr><tr><td>有效时间</td><td><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。<br> <code>sessionStorage</code> 数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。<br><code>cookie</code> 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</td></tr><tr><td>作用域</td><td><code>sessionStorage</code>  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。<br><code>localStorage</code> 在所有同源窗口中都是共享的。<br><code>cookie</code> 在所有同源窗口中都是共享的。</td></tr></tbody></table><h3 id="关于cookie"><a href="#关于cookie" class="headerlink" title="关于cookie"></a>关于cookie</h3><p>cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。</p><p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</p><p>在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 语义化</title>
      <link href="/2022/08/05/html-yu-yi-hua/"/>
      <url>/2022/08/05/html-yu-yi-hua/</url>
      
        <content type="html"><![CDATA[<ol><li>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；</li><li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的；</li><li>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO（搜索引擎优化）；</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5的新特性</title>
      <link href="/2022/08/05/html5-de-xin-te-xing/"/>
      <url>/2022/08/05/html5-de-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><ul><li>画布： <code>canvas</code>;</li><li>音视频： <code>video</code> 和 <code>audio</code> 元素;</li><li>web存储：本地离线存储 <code>localStorage</code> 长期存储数据，浏览器关闭后数据不丢失；<code>sessionStorage</code> 的数据在浏览器关闭后自动删除;</li><li>语义化更好的内容元素，比如 <code>article</code>、<code>footer</code>、<code>header</code>、<code>main</code>、<code>nav</code>、<code>section</code>;</li><li>表单控件，<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code>;</li><li>新的技术 <code>webworker</code>， <code>websocket</code>；</li><li>新的文档属性 <code>document.visibilityState</code>。</li></ul><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><ul><li>纯表现的元素：<code>basefont</code>，<code>big</code>，<code>center</code>，<code>font</code>, <code>s</code>，<code>strike</code>，<code>tt</code>，<code>u</code>;</li><li>对可用性产生负面影响的元素：<code>frame</code>，<code>frameset</code>，<code>noframes</code>；</li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重绘和重排（回流）</title>
      <link href="/2022/08/05/chong-hui-he-chong-pai-hui-liu/"/>
      <url>/2022/08/05/chong-hui-he-chong-pai-hui-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 <code>background-color</code>，这样的操作称为<mark>重绘</mark>。</p><h2 id="重排（回流）"><a href="#重排（回流）" class="headerlink" title="重排（回流）"></a>重排（回流）</h2><p>当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作称为<mark>回流</mark>。</p><br><ins>一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</ins><h3 id="常见引起回流属性和方法"><a href="#常见引起回流属性和方法" class="headerlink" title="常见引起回流属性和方法"></a>常见引起回流属性和方法</h3><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p><ol><li>添加或者删除可见的 DOM 元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度；</li><li>内容变化，比如用户在 input 框中输入文字；</li><li>浏览器窗口尺寸改变——resize事件发生时；</li><li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性；</li><li>设置 <code>style</code> 属性的值；</li><li>修改网页的默认字体时。</li></ol><p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong>回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><p><em>常见引起重绘属性和方法：</em><br><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-14.png" alt="常见引起回流属性和方法"></p><p><em>常见引起回流属性和方法：</em><br><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-13.png" alt="常见引起重绘属性和方法"></p><h3 id="如何减少回流？"><a href="#如何减少回流？" class="headerlink" title="如何减少回流？"></a>如何减少回流？</h3><ol><li>使用 <code>transform</code> 替代 <code>top</code>；</li><li>不要把节点的属性值放在一个循环里当成循环里的变量；</li><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局；</li><li>把 DOM 离线后修改。如：使用 <code>documentFragment</code> 对象在内存里操作 DOM；</li><li>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 <code>class</code>，然后修改 DOM 的 <code>className</code>。</li></ol><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器解析过程</title>
      <link href="/2022/08/04/liu-lan-qi-jie-xi-guo-cheng/"/>
      <url>/2022/08/04/liu-lan-qi-jie-xi-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>在浏览器渲染过程当中，遇到<code>JavaScript</code> 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 <code>JavaScript</code>，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p><p>也就是说，如果我们想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为我们可以给 script 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</p><br><p>js脚本没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>defer</td><td>表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</td></tr><tr><td>async</td><td>表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</td></tr></tbody></table><p><img src="/../images/defer%E3%80%81async%E5%8C%BA%E5%88%AB.png" alt="defer、async区别"></p><p><strong>文档的预解析:</strong><br> Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p><p><strong>CSS 如何阻塞文档解析？</strong><br>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 <code>CSSOM</code> 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 <code>CSSOM</code>，然后再执行 JavaScript，最后再继续文档的解析。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的渲染原理</title>
      <link href="/2022/08/04/liu-lan-qi-de-xuan-ran-yuan-li/"/>
      <url>/2022/08/04/liu-lan-qi-de-xuan-ran-yuan-li/</url>
      
        <content type="html"><![CDATA[<ol><li>首先解析收到的文档，根据文档定义构建一棵 <code>DOM 树</code>，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成 <code>CSSOM 规则树</code>。</li><li>根据 <code>DOM 树</code>和 <code>CSSOM 规则树</code>构建渲染树。渲染树的节点被称为<mark>渲染对象</mark>，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做<mark>回流</mark>）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动<mark>重排</mark>”。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ol><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器内核的理解</title>
      <link href="/2022/08/04/liu-lan-qi-nei-he-de-li-jie/"/>
      <url>/2022/08/04/liu-lan-qi-nei-he-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p>主要分成两部分：<code>渲染引擎</code>和<code>JS引擎</code>。<br><code>渲染引擎</code>的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。<br><code>JS引擎</code>：解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。<br><br><br><strong>常见的浏览器内核比较</strong></p><table><thead><tr><th>浏览器内核名称</th><th>简介</th></tr></thead><tbody><tr><td>Gecko</td><td>这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</td></tr><tr><td>Presto</td><td>Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</td></tr><tr><td>Webkit</td><td>Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</td></tr><tr><td>Blink</td><td>谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</td></tr></tbody></table><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行内元素与块级元素</title>
      <link href="/2022/08/03/xing-nei-yuan-su-yu-kuai-ji-yuan-su/"/>
      <url>/2022/08/03/xing-nei-yuan-su-yu-kuai-ji-yuan-su/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th></th><th>定义</th><th>常用元素</th></tr></thead><tbody><tr><td>行内元素</td><td>一个行内元素只占据它对应标签的边框所包含的空间。<ins>（没有宽高）</ins></td><td><code>a</code> <code>b</code> <code>span</code> <code>img</code> <code>strong</code> <code>sub</code> <code>sup</code> <code>button</code> <code>input</code> <code>label</code> <code>select</code> <code>textarea</code></td></tr><tr><td>块级元素</td><td>块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。</td><td><code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code> <code>h3</code> <code>h4</code> <code>h5</code> <code>h6</code> <code>p</code></td></tr></tbody></table><br><strong>两者区别：</strong><br>1. <mark>格式上</mark>，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。<br>2. <mark>内容上</mark>，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。<br>3. 行内元素与块级元素属性的不同，主要是盒模型属性上：<mark>行内元素</mark>不支持设置宽高；<mark>行内元素</mark>支持水平方向的padding、border、margin；行内元素可以设置垂直方向的padding、border、margin，但是不会影响布局。<br><br><strong>行内块元素：</strong><p>通过<code>display:inline-block</code>设置，既有行内元素的特点也有块级元素的特点：<br>1.可以改变宽高（块级元素特点）<br>2.不独立成行（行内元素特点）</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SGML 、 HTML 、XML 和 XHTML 的区别</title>
      <link href="/2022/08/03/sgml-html-xml-he-xhtml-de-qu-bie/"/>
      <url>/2022/08/03/sgml-html-xml-he-xhtml-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><mark>SGML</mark> 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。<br><br><br><mark>HTML</mark> 是超文本标记语言，主要是用于规定怎么显示网页。<br><br><br><mark>XML</mark> 是可扩展标记语言，是未来网页语言的发展方向。<br><br><br><ins><mark>XML</mark> 和 <mark>HTML</mark> 的最大区别就在于 <mark>XML</mark> 的标签是可以自己创建的，数量无限多,而 <mark>HTML</mark> 的标签都是固定的而且数量有限。</ins><br><br><br><mark>XHTML</mark> 也是现在基本上所有网页都在用的标记语言，他其实和 <mark>HTML</mark> 没什么本质的区别，标签都一样，用法也都一样，就是比 <mark>HTML</mark> 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Front-matter选项作用</title>
      <link href="/2022/08/03/front-matter-xuan-xiang-zuo-yong/"/>
      <url>/2022/08/03/front-matter-xuan-xiang-zuo-yong/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><mark>Markdown</mark> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根据 <mark>_config.yml</mark> 中的 author</td><td>文章作者</td></tr><tr><td>img</td><td><mark>eatureImages</mark> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <mark><a href="http://xxx.com/xxx.jpg">http://xxx.com/xxx.jpg</a></mark></td></tr><tr><td>top</td><td><mark>true</mark></td><td>推荐文章（文章是否置顶），如果 top 值为 <mark>true</mark>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><mark>false</mark></td><td>隐藏文章，如果hide值为true，则文章不会在首页显示</td></tr><tr><td>cover</td><td><mark>false</mark></td><td><mark>v1.0.2</mark>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><mark>v1.0.2</mark>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <mark>password</mark> 的值，该值必须是用 <mark>SHA256</mark> 加密后的密码，防止被他人识破。前提是在主题的 <mark>config.yml</mark> 中激活了 <mark>verifyPassword</mark> 选项</td></tr><tr><td>toc</td><td>true</td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <mark>config.yml</mark> 中激活了 toc 选项</td></tr><tr><td>mathjax</td><td><mark>false</mark></td><td>是否开启数学公式支持 ，本文章是否开启 <mark>mathjax</mark>，且需要在主题的 <mark>_config.yml</mark> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><br><p><a href="https://blog.17lai.site/posts/cf0f47fd">Hexo Markdown以及各种插件功能测试</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOCTYPE的作用</title>
      <link href="/2022/08/02/doctype-de-zuo-yong/"/>
      <url>/2022/08/02/doctype-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<p><big>相关知识点:</big><br>IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的<br><mark>&lt;!DOCTYPE&gt;</mark>声明位于HTML文档中的第一行，处于<mark>html</mark>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<br>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</p><p><mark>&lt;!DOCTYPE&gt;</mark>声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。<br>在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。<br>在<mark>html5</mark>之后不再需要指定 DTD 文档，因为<mark>html5</mark>以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而<mark>html5</mark>不再基于 SGML 了，所以不再需要使用 DTD。</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
